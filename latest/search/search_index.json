{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"autoware_core","text":""},{"location":"#autoware_core","title":"autoware_core","text":"<ul> <li>An Autoware repository that contains a basic set of high-quality, stable ROS packages for autonomous driving.</li> </ul> <ul> <li>Although this repository is currently empty, porting of code from Universe to Core will begin once the interfaces for Autoware Core/Universe have been finalized, as per ongoing Autoware Architecture WG discussions.</li> <li>A more detailed explanation about Autoware Core can be found on the Autoware concepts documentation page.</li> </ul> <ul> <li>For researchers and developers who want to extend the functionality of Autoware Core with experimental, cutting-edge ROS packages, see Autoware Universe.</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at conduct@autoware.org. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#contributing","title":"Contributing","text":"<p>See https://autowarefoundation.github.io/autoware-documentation/main/contributing/.</p>"},{"location":"DISCLAIMER/","title":"DISCLAIMER","text":"<p>DISCLAIMER</p> <p>\u201cAutoware\u201d will be provided by The Autoware Foundation under the Apache License 2.0. This \u201cDISCLAIMER\u201d will be applied to all users of Autoware (a \u201cUser\u201d or \u201cUsers\u201d) with the Apache License 2.0 and Users shall hereby approve and acknowledge all the contents specified in this disclaimer below and will be deemed to consent to this disclaimer without any objection upon utilizing or downloading Autoware.</p> <p>Disclaimer and Waiver of Warranties</p> <ol> <li> <p>AUTOWARE FOUNDATION MAKES NO REPRESENTATION OR WARRANTY OF ANY KIND,    EXPRESS OR IMPLIED, WITH RESPECT TO PROVIDING AUTOWARE (the \u201cService\u201d)    including but not limited to any representation or warranty (i) of fitness or    suitability for a particular purpose contemplated by the Users, (ii) of the    expected functions, commercial value, accuracy, or usefulness of the Service,    (iii) that the use by the Users of the Service complies with the laws and    regulations applicable to the Users or any internal rules established by    industrial organizations, (iv) that the Service will be free of interruption or    defects, (v) of the non-infringement of any third party's right and (vi) the    accuracy of the content of the Services and the software itself.</p> </li> <li> <p>The Autoware Foundation shall not be liable for any damage incurred by the    User that are attributable to the Autoware Foundation for any reasons    whatsoever. UNDER NO CIRCUMSTANCES SHALL THE AUTOWARE FOUNDATION BE LIABLE FOR    INCIDENTAL, INDIRECT, SPECIAL OR FUTURE DAMAGES OR LOSS OF PROFITS.</p> </li> <li> <p>A User shall be entirely responsible for the content posted by the User and    its use of any content of the Service or the Website. If the User is held    responsible in a civil action such as a claim for damages or even in a criminal    case, the Autoware Foundation and member companies, governments and academic &amp;    non-profit organizations and their directors, officers, employees and agents    (collectively, the \u201cIndemnified Parties\u201d) shall be completely discharged from    any rights or assertions the User may have against the Indemnified Parties, or    from any legal action, litigation or similar procedures.</p> </li> </ol> <p>Indemnity</p> <p>A User shall indemnify and hold the Indemnified Parties harmless from any of their damages, losses, liabilities, costs or expenses (including attorneys' fees or criminal compensation), or any claims or demands made against the Indemnified Parties by any third party, due to or arising out of, or in connection with utilizing Autoware (including the representations and warranties), the violation of applicable Product Liability Law of each country (including criminal case) or violation of any applicable laws by the Users, or the content posted by the User or its use of any content of the Service or the Website.</p>"},{"location":"autoware_core/","title":"autoware_core","text":""},{"location":"common/autoware_component_interface_specs/","title":"autoware_component_interface_specs","text":""},{"location":"common/autoware_component_interface_specs/#autoware_component_interface_specs","title":"autoware_component_interface_specs","text":"<p>This package defines the standardized component interface specifications for Autoware Core, ensuring consistent communication and interaction between various components in the Autoware autonomous driving stack.</p>"},{"location":"common/autoware_component_interface_specs/#purpose","title":"Purpose","text":"<p>The purpose of this package is to:</p> <ul> <li>Provide a single source of truth for component interface definitions</li> <li>Ensure consistency across different implementations</li> <li>Facilitate modular development and component interchangeability</li> <li>Document the communication protocols between Autoware Core components</li> </ul>"},{"location":"common/autoware_component_interface_specs/#structure","title":"Structure","text":"<p>The package contains interface specifications for various components, including:</p> <ul> <li>Message definitions</li> <li>Service interfaces</li> <li>Action interfaces</li> </ul>"},{"location":"common/autoware_component_interface_specs/#usage","title":"Usage","text":"<p>To use these interface specifications in your component:</p> <ol> <li> <p>Add this package as a dependency in your package.xml:</p> <pre><code>&lt;depend&gt;autoware_component_interface_specs&lt;/depend&gt;\n</code></pre> </li> <li> <p>Use the provided interfaces in your component code.</p> <pre><code>#include &lt;autoware/component_interface_specs/localization.hpp&gt;\n// Example: Creating a publisher using the interface specs\nusing KinematicState = autoware::component_interface_specs::localization::KinematicState;\nrclcpp::Publisher&lt;KinematicState::Message&gt;::SharedPtr publisher_ =\ncreate_publisher&lt;KinematicState::Message&gt;(\nKinematicState::name,\nautoware::component_interface_specs::get_qos&lt;KinematicState&gt;());\n// Example: Creating a subscription using the interface specs\nauto subscriber_ = create_subscription&lt;KinematicState::Message&gt;(\nKinematicState::name,\nautoware::component_interface_specs::get_qos&lt;KinematicState&gt;(),\nstd::bind(&amp;YourClass::callback, this, std::placeholders::1));\n</code></pre> </li> </ol>"},{"location":"common/autoware_geography_utils/","title":"autoware_geography_utils","text":""},{"location":"common/autoware_geography_utils/#autoware_geography_utils","title":"autoware_geography_utils","text":""},{"location":"common/autoware_geography_utils/#purpose","title":"Purpose","text":"<p>This package contains geography-related utility functions used by other Autoware packages. It provides functionality for geographic coordinate transformations, height calculations, and Lanelet2 map projections.</p>"},{"location":"common/autoware_global_parameter_loader/Readme/","title":"Autoware Global Parameter Loader","text":""},{"location":"common/autoware_global_parameter_loader/Readme/#autoware-global-parameter-loader","title":"Autoware Global Parameter Loader","text":"<p>This package is to set common ROS parameters to each node.</p>"},{"location":"common/autoware_global_parameter_loader/Readme/#usage","title":"Usage","text":"<p>Add the following lines to the launch file of the node in which you want to get global parameters.</p> <pre><code>&lt;!-- Global parameters --&gt;\n&lt;include file=\"$(find-pkg-share autoware_global_parameter_loader)/launch/global_params.launch.py\"&gt;\n&lt;arg name=\"vehicle_model\" value=\"$(var vehicle_model)\"/&gt;\n&lt;/include&gt;\n</code></pre> <p>The vehicle model parameter is read from <code>config/vehicle_info.param.yaml</code> in <code>vehicle_model</code>_description package.</p>"},{"location":"common/autoware_global_parameter_loader/Readme/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p>Currently only vehicle_info is loaded by this launcher.</p>"},{"location":"common/autoware_interpolation/","title":"Interpolation package","text":""},{"location":"common/autoware_interpolation/#interpolation-package","title":"Interpolation package","text":"<p>This package supplies linear and spline interpolation functions.</p>"},{"location":"common/autoware_interpolation/#linear-interpolation","title":"Linear Interpolation","text":"<p><code>lerp(src_val, dst_val, ratio)</code> (for scalar interpolation) interpolates <code>src_val</code> and <code>dst_val</code> with <code>ratio</code>. This will be replaced with <code>std::lerp(src_val, dst_val, ratio)</code> in <code>C++20</code>.</p> <p><code>lerp(base_keys, base_values, query_keys)</code> (for vector interpolation) applies linear regression to each two continuous points whose x values are<code>base_keys</code> and whose y values are <code>base_values</code>. Then it calculates interpolated values on y-axis for <code>query_keys</code> on x-axis.</p>"},{"location":"common/autoware_interpolation/#spline-interpolation","title":"Spline Interpolation","text":"<p><code>spline(base_keys, base_values, query_keys)</code> (for vector interpolation) applies spline regression to each two continuous points whose x values are<code>base_keys</code> and whose y values are <code>base_values</code>. Then it calculates interpolated values on y-axis for <code>query_keys</code> on x-axis.</p>"},{"location":"common/autoware_interpolation/#evaluation-of-calculation-cost","title":"Evaluation of calculation cost","text":"<p>We evaluated calculation cost of spline interpolation for 100 points, and adopted the best one which is tridiagonal matrix algorithm. Methods except for tridiagonal matrix algorithm exists in <code>spline_interpolation</code> package, which has been removed from Autoware.</p> Method Calculation time Tridiagonal Matrix Algorithm 0.007 [ms] Preconditioned Conjugate Gradient 0.024 [ms] Successive Over-Relaxation 0.074 [ms]"},{"location":"common/autoware_interpolation/#spline-interpolation-algorithm","title":"Spline Interpolation Algorithm","text":"<p>Assuming that the size of <code>base_keys</code> (\\(x_i\\)) and <code>base_values</code> (\\(y_i\\)) are \\(N + 1\\), we aim to calculate spline interpolation with the following equation to interpolate between \\(y_i\\) and \\(y_{i+1}\\).</p> \\[ Y_i(x) = a_i (x - x_i)^3 + b_i (x - x_i)^2 + c_i (x - x_i) + d_i \\ \\ \\ (i = 0, \\dots, N-1) \\] <p>Constraints on spline interpolation are as follows. The number of constraints is \\(4N\\), which is equal to the number of variables of spline interpolation.</p> \\[ \\begin{align} Y_i (x_i) &amp; = y_i \\ \\ \\ (i = 0, \\dots, N-1) \\\\ Y_i (x_{i+1}) &amp; = y_{i+1} \\ \\ \\ (i = 0, \\dots, N-1) \\\\ Y_i '(x_{i+1}) &amp; = Y_{i+1}' (x_{i+1}) \\ \\ \\ (i = 0, \\dots, N-2) \\\\ Y_i (x_{i+1})'' &amp; = Y_{i+1}'' (x_{i+1}) \\ \\ \\ (i = 0, \\dots, N-2) \\\\ Y_0 ''(x_0) &amp; = 0 \\\\ Y_{N-1}'' (x_N) &amp; = 0 \\end{align} \\] <p>According to this article, spline interpolation is formulated as the following linear equation.</p> \\[ \\begin{align}  \\begin{pmatrix}     2(h_0 + h_1) &amp; h_1 \\\\     h_0 &amp; 2 (h_1 + h_2) &amp; h_2 &amp; &amp; O \\\\         &amp;     &amp;     &amp; \\ddots \\\\     O &amp;     &amp;     &amp;       &amp; h_{N-2} &amp; 2 (h_{N-2} + h_{N-1})  \\end{pmatrix}  \\begin{pmatrix}     v_1 \\\\ v_2 \\\\ v_3 \\\\ \\vdots \\\\ v_{N-1}  \\end{pmatrix}=  \\begin{pmatrix}     w_1 \\\\ w_2 \\\\ w_3 \\\\ \\vdots \\\\ w_{N-1}  \\end{pmatrix} \\end{align} \\] <p>where</p> \\[ \\begin{align} h_i &amp; = x_{i+1} - x_i \\ \\ \\ (i = 0, \\dots, N-1) \\\\ w_i &amp; = 6 \\left(\\frac{y_{i+1} - y_{i+1}}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}}\\right) \\ \\ \\ (i = 1, \\dots, N-1) \\end{align} \\] <p>The coefficient matrix of this linear equation is tridiagonal matrix. Therefore, it can be solve with tridiagonal matrix algorithm, which can solve linear equations without gradient descent methods.</p> <p>Solving this linear equation with tridiagonal matrix algorithm, we can calculate coefficients of spline interpolation as follows.</p> \\[ \\begin{align} a_i &amp; = \\frac{v_{i+1} - v_i}{6 (x_{i+1} - x_i)} \\ \\ \\ (i = 0, \\dots, N-1) \\\\ b_i &amp; = \\frac{v_i}{2} \\ \\ \\ (i = 0, \\dots, N-1) \\\\ c_i &amp; = \\frac{y_{i+1} - y_i}{x_{i+1} - x_i} - \\frac{1}{6}(x_{i+1} - x_i)(2 v_i + v_{i+1}) \\ \\ \\ (i = 0, \\dots, N-1) \\\\ d_i &amp; = y_i \\ \\ \\ (i = 0, \\dots, N-1) \\end{align} \\]"},{"location":"common/autoware_interpolation/#tridiagonal-matrix-algorithm","title":"Tridiagonal Matrix Algorithm","text":"<p>We solve tridiagonal linear equation according to this article where variables of linear equation are expressed as follows in the implementation.</p> \\[ \\begin{align}  \\begin{pmatrix}     b_0 &amp; c_0 &amp;     &amp; \\\\     a_0 &amp; b_1 &amp; c_2 &amp; O \\\\         &amp;     &amp; \\ddots \\\\     O &amp;     &amp; a_{N-2} &amp;  b_{N-1}  \\end{pmatrix} x = \\begin{pmatrix}     d_0 \\\\ d_2 \\\\ d_3 \\\\ \\vdots \\\\ d_{N-1}  \\end{pmatrix} \\end{align} \\]"},{"location":"common/autoware_kalman_filter/","title":"kalman_filter","text":""},{"location":"common/autoware_kalman_filter/#kalman_filter","title":"kalman_filter","text":""},{"location":"common/autoware_kalman_filter/#overview","title":"Overview","text":"<p>This package contains the kalman filter with time delay and the calculation of the kalman filter.</p>"},{"location":"common/autoware_kalman_filter/#design","title":"Design","text":"<p>The Kalman filter is a recursive algorithm used to estimate the state of a dynamic system. The Time Delay Kalman filter is based on the standard Kalman filter and takes into account possible time delays in the measured values.</p>"},{"location":"common/autoware_kalman_filter/#standard-kalman-filter","title":"Standard Kalman Filter","text":""},{"location":"common/autoware_kalman_filter/#system-model","title":"System Model","text":"<p>Assume that the system can be represented by the following linear discrete model:</p> \\[ x_{k} = A x_{k-1} + B u_{k} \\\\ y_{k} = C x_{k-1} \\] <p>where,</p> <ul> <li>\\(x_k\\) is the state vector at time \\(k\\).</li> <li>\\(u_k\\) is the control input vector at time \\(k\\).</li> <li>\\(y_k\\) is the measurement vector at time \\(k\\).</li> <li>\\(A\\) is the state transition matrix.</li> <li>\\(B\\) is the control input matrix.</li> <li>\\(C\\) is the measurement matrix.</li> </ul>"},{"location":"common/autoware_kalman_filter/#prediction-step","title":"Prediction Step","text":"<p>The prediction step consists of updating the state and covariance matrices:</p> \\[ x_{k|k-1} = A x_{k-1|k-1} + B u_{k} \\\\ P_{k|k-1} = A P_{k-1|k-1} A^{T} + Q \\] <p>where,</p> <ul> <li>\\(x_{k|k-1}\\) is the priori state estimate.</li> <li>\\(P_{k|k-1}\\) is the priori covariance matrix.</li> </ul>"},{"location":"common/autoware_kalman_filter/#update-step","title":"Update Step","text":"<p>When the measurement value \\( y_k \\) is received, the update steps are as follows:</p> \\[ K_k = P_{k|k-1} C^{T} (C P_{k|k-1} C^{T} + R)^{-1} \\\\ x_{k|k} = x_{k|k-1} + K_k (y_{k} - C x_{k|k-1}) \\\\ P_{k|k} = (I - K_k C) P_{k|k-1} \\] <p>where,</p> <ul> <li>\\(K_k\\) is the Kalman gain.</li> <li>\\(x_{k|k}\\) is the posterior state estimate.</li> <li>\\(P_{k|k}\\) is the posterior covariance matrix.</li> </ul>"},{"location":"common/autoware_kalman_filter/#extension-to-time-delay-kalman-filter","title":"Extension to Time Delay Kalman Filter","text":"<p>For the Time Delay Kalman filter, it is assumed that there may be a maximum delay of step (\\(d\\)) in the measured value. To handle this delay, we extend the state vector to:</p> \\[ (x_{k})_e = \\begin{bmatrix} x_k \\\\ x_{k-1} \\\\ \\vdots \\\\ x_{k-d+1} \\end{bmatrix} \\] <p>The corresponding state transition matrix (\\(A_e\\)) and process noise covariance matrix (\\(Q_e\\)) are also expanded:</p> \\[ A_e = \\begin{bmatrix} A &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ I &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; I &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{bmatrix}, \\quad Q_e = \\begin{bmatrix} Q &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{bmatrix} \\]"},{"location":"common/autoware_kalman_filter/#prediction-step_1","title":"Prediction Step","text":"<p>The prediction step consists of updating the extended state and covariance matrices.</p> <p>Update extension status:</p> \\[ (x_{k|k-1})_e = \\begin{bmatrix} A &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ I &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; I &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{bmatrix} \\begin{bmatrix} x_{k-1|k-1} \\\\ x_{k-2|k-1} \\\\ \\vdots \\\\ x_{k-d|k-1} \\end{bmatrix} \\] <p>Update extended covariance matrix:</p> \\[ (P_{k|k-1})_e = \\begin{bmatrix} A &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ I &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; I &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{bmatrix} \\begin{bmatrix} P_{k-1|k-1}^{(1)} &amp; P_{k-1|k-1}^{(1,2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(1,d)} \\\\ P_{k-1|k-1}^{(2,1)} &amp; P_{k-1|k-1}^{(2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(2,d)} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ P_{k-1|k-1}^{(d,1)} &amp; P_{k-1|k-1}^{(d,2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(d)} \\end{bmatrix} \\begin{bmatrix}  A^T &amp; I &amp; 0 &amp; \\cdots &amp; 0 \\\\  0 &amp; 0 &amp; I &amp; \\cdots &amp; 0 \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\  \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0  \\end{bmatrix} +  \\begin{bmatrix}  Q &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\  \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0  \\end{bmatrix} \\] <p>\\(\\Longrightarrow\\)</p> \\[ (P_{k|k-1})_e = \\begin{bmatrix} A P_{k-1|k-1}^{(1)} A^T + Q &amp; A P_{k-1|k-1}^{(1,2)} &amp; \\cdots &amp; A P_{k-1|k-1}^{(1,d)} \\\\ P_{k-1|k-1}^{(2,1)} A^T &amp; P_{k-1|k-1}^{(2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(2,d)} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ P_{k-1|k-1}^{(d,1)} A^T &amp; P_{k-1|k-1}^{(d,2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(d)} \\end{bmatrix} \\] <p>where,</p> <ul> <li>\\((x_{k|k-1})_e\\) is the priori extended state estimate.</li> <li>\\((P_{k|k-1})_e\\) is the priori extended covariance matrix.</li> </ul>"},{"location":"common/autoware_kalman_filter/#update-step_1","title":"Update Step","text":"<p>When receiving the measurement value ( \\(y_{k}\\) ) with a delay of ( \\(ds\\) ), the update steps are as follows:</p> <p>Update kalman gain:</p> \\[ K_k = \\begin{bmatrix} P_{k|k-1}^{(1)} C^T \\\\ P_{k|k-1}^{(2)} C^T \\\\ \\vdots \\\\ P_{k|k-1}^{(ds)} C^T \\\\ \\vdots \\\\ P_{k|k-1}^{(d)} C^T \\end{bmatrix} (C P_{k|k-1}^{(ds)} C^T + R)^{-1} \\] <p>Update extension status:</p> \\[ (x_{k|k})_e = \\begin{bmatrix} x_{k|k-1} \\\\ x_{k-1|k-1} \\\\ \\vdots \\\\ x_{k-d+1|k-1} \\end{bmatrix} + \\begin{bmatrix} K_k^{(1)} \\\\ K_k^{(2)} \\\\ \\vdots \\\\ K_k^{(ds)} \\\\ \\vdots \\\\ K_k^{(d)} \\end{bmatrix} (y_k - C x_{k-ds|k-1}) \\] <p>Update extended covariance matrix:</p> \\[  (P_{k|k})_e = \\left(I -  \\begin{bmatrix}  K_k^{(1)} C \\\\  K_k^{(2)} C \\\\  \\vdots \\\\  K_k^{(ds)} C \\\\  \\vdots \\\\  K_k^{(d)} C  \\end{bmatrix}\\right)  \\begin{bmatrix}  P_{k|k-1}^{(1)} &amp; P_{k|k-1}^{(1,2)} &amp; \\cdots &amp; P_{k|k-1}^{(1,d)} \\\\  P_{k|k-1}^{(2,1)} &amp; P_{k|k-1}^{(2)} &amp; \\cdots &amp; P_{k|k-1}^{(2,d)} \\\\  \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\  P_{k|k-1}^{(d,1)} &amp; P_{k|k-1}^{(d,2)} &amp; \\cdots &amp; P_{k|k-1}^{(d)}  \\end{bmatrix} \\] <p>where,</p> <ul> <li>\\(K_k\\) is the Kalman gain.</li> <li>\\((x_{k|k})_e\\) is the posterior extended state estimate.</li> <li>\\((P_{k|k})_e\\) is the posterior extended covariance matrix.</li> <li>\\(C\\) is the measurement matrix, which only applies to the delayed state part.</li> </ul>"},{"location":"common/autoware_kalman_filter/#example-usage","title":"Example Usage","text":"<p>This section describes Example Usage of KalmanFilter.</p> <ul> <li>Initialization</li> </ul> <pre><code>#include \"autoware/kalman_filter/kalman_filter.hpp\"\n\n// Define system parameters\nint dim_x = 2; // state vector dimensions\nint dim_y = 1; // measure vector dimensions\n\n// Initial state\nEigen::MatrixXd x0 = Eigen::MatrixXd::Zero(dim_x, 1);\nx0 &lt;&lt; 0.0, 0.0;\n\n// Initial covariance matrix\nEigen::MatrixXd P0 = Eigen::MatrixXd::Identity(dim_x, dim_x);\nP0 *= 100.0;\n\n// Define state transition matrix\nEigen::MatrixXd A = Eigen::MatrixXd::Identity(dim_x, dim_x);\nA(0, 1) = 1.0;\n\n// Define measurement matrix\nEigen::MatrixXd C = Eigen::MatrixXd::Zero(dim_y, dim_x);\nC(0, 0) = 1.0;\n\n// Define process noise covariance matrix\nEigen::MatrixXd Q = Eigen::MatrixXd::Identity(dim_x, dim_x);\nQ *= 0.01;\n\n// Define measurement noise covariance matrix\nEigen::MatrixXd R = Eigen::MatrixXd::Identity(dim_y, dim_y);\nR *= 1.0;\n\n// Initialize Kalman filter\nautoware::kalman_filter::KalmanFilter kf;\nkf.init(x0, P0);\n</code></pre> <ul> <li>Predict step</li> </ul> <pre><code>const Eigen::MatrixXd x_next = A * x0;\nkf.predict(x_next, A, Q);\n</code></pre> <ul> <li>Update step</li> </ul> <pre><code>// Measured value\nEigen::MatrixXd y = Eigen::MatrixXd::Zero(dim_y, 1);\nkf.update(y, C, R);\n</code></pre> <ul> <li>Get the current estimated state and covariance matrix</li> </ul> <pre><code>Eigen::MatrixXd x_curr = kf.getX();\nEigen::MatrixXd P_curr = kf.getP();\n</code></pre>"},{"location":"common/autoware_kalman_filter/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<ul> <li>Delay Step Check: Ensure that the <code>delay_step</code> provided during the update does not exceed the maximum delay steps set during initialization.</li> </ul>"},{"location":"common/autoware_lanelet2_utils/","title":"autoware_lanelet2_utils","text":""},{"location":"common/autoware_lanelet2_utils/#autoware_lanelet2_utils","title":"autoware_lanelet2_utils","text":""},{"location":"common/autoware_lanelet2_utils/#nomenclature","title":"Nomenclature","text":"<p>This package aims to strictly define the meaning of several words to clarify the documentation and API's scope. In the table below, <code>codespace</code> words are given specific meanings when used in the API and API description. italic words are emphasized to indicate that it refers to social common sense which often comes with ambiguity. To help disambiguate the meaning, illustration is provided. \"Lanelet\" refers to the entity of a<code>lanelet::ConstLanelet</code> object in order to distinguish with the word \"lane\" used in social customs. <code>A</code> and <code>B</code> stands for some Lanelets objects.</p> Word Meaning Illustration <code>driving</code> The vehicle position belongs to the designated Lanelet. In each map, green Lanelet are the <code>driving</code> lanes of the vehicle.Open <code>boundary</code>,<code>entry</code>,<code>exit</code> The <code>boundary</code> of a Lanelet refers to the left or right Linestring. Open <code>adjacent</code> If A is <code>adjacent</code> to B, A and B share a common <code>boundary</code> with same direction either on the left or right side. In each map, orange Lanelet is <code>adjacent</code> to green Lanelet.Open <code>same_direction</code> Lanelet A and Lanelet B are <code>same_direction</code> if A and B are directly or indirectly <code>adjacent</code> to each other. In each map, orange Lanelets are <code>same_direction</code> as green Lanelet.Open <code>bundle</code> A <code>bundle</code> refers to a transitive closure set of Lanelets which are <code>same_direction</code> to each other. The enclosed sets of Lanelets are <code>bundle</code>s.Open <code>opposite</code> If A is <code>opposite</code> to B, A and B share a common <code>boundary</code> with opposite direction. In the first map, green Lanelet and orange Lanelet are <code>opposite</code> to each other.In the second map, two red Lanelets are not <code>opposite</code> relation because they do not share a common LineString.Open <code>opposite_direction</code> If A and B are <code>opposite_direction</code>, the <code>bundle</code> of A and B are directly <code>opposite</code> to each other. In the each map, green Lanelet and orange Lanelet are <code>opposite_direction</code> because their <code>bundle</code>s(enclosed in dotted line) are <code>opposite</code> relation.Open <code>connected</code> A is <code>connected</code> to(from) B if and only if the <code>exit</code>(<code>entry</code>) of A is identical to the <code>entry</code>(<code>exit</code>) of B. A is connected to B, and B is connected from A.Open <code>following</code> The <code>following</code> Lanelets of A is the list of Lanelets to which A is <code>connected</code>. In each map, orange Lanelets are the <code>following</code> of green Lanelet.Open <code>previous</code> The <code>previous</code> Lanelets of A is the list of Lanelets from which A is <code>connected</code>. In each map, orange Lanelets are the <code>previous</code> of green Lanelet.  Open <code>conflicting</code> A is <code>conflicting</code> with B if A and B are geometrically intersecting. <code>merging</code> A is said to be <code>merging</code> Lanelet of B if and only if A is <code>conflicting</code> with B and both A and B are connected to a common Lanelet. In each map, one of the orange Lanelet is a <code>merging</code> Lanelet of the other orange Lanelet.Open <code>sibling</code> The designated Lanelets are referred to as <code>sibling</code> if all of them are <code>connected</code> from a common Lanelet. In each map, orange Lanelets are <code>sibling</code>s.Open <code>oncoming</code> TBD TBD <code>upcoming</code> TBD TBD <code>sequence</code> <code>sequence</code> is a list of Lanelets whose each element is <code>connected from</code> or <code>adjacent to</code> the previous element. Open"},{"location":"common/autoware_lanelet2_utils/#api-description","title":"API description","text":"Header function description average computational complexity illustration <code>&lt;autoware_lanelet2_utils/kind.hpp&gt;</code> <code>is_road_lane</code> This function returns <code>true</code> if the input Lanelet is <code>road</code> subtype. \\(O(1)\\) <code>is_shoulder_lane</code> This function returns <code>true</code> if the input Lanelet is <code>road_shoulder</code> subtype. \\(O(1)\\) <code>is_bicycle_lane</code> This function returns <code>true</code> if the input Lanelet is <code>bicycle_lane</code> subtype. \\(O(1)\\) <code>&lt;autoware_lanelet2_utils/topology.hpp&gt;</code> <code>instantiate_routing_graph</code> This function creates a <code>RoutingGraph</code> object only from \"road\" lanes, which means \"road_shoulder\" and \"bicycle_lane\" Lanelets are inaccessible from left/right adjacency. <code>left_lanelet</code> This function ignores the permission of lane change. Also it ignores <code>shoulder</code> and <code>bicycle</code> Lanelet. \\(O(1)\\) In the first map, the green Lanelet is the <code>left_lanelet</code> of the orange Lanelet.In the second and third map, the <code>left_lanelet</code> of the orange Lanelet is <code>null</code>.Open <code>right_lanelet</code> same as above <code>left_lanelet</code> \\(O(1)\\) <code>left_opposite_lanelet</code> same as below <code>right_opposite_lanelet</code> \\(O(1)\\)see <code>findUsage</code> for detail <code>right_opposite_lanelet</code> This functions returns the right <code>opposite</code> Lanelet of the input Lanelet if available, otherwise returns null. \\(O(1)\\)see <code>findUsage</code> for detail In the first and second map, the green Lanelet is the <code>right_opposite_lanelet</code> of the orange Lanelet.In the third map, the <code>right_opposite_lanelet</code> of the orange Lanelet is <code>null</code>.Open <code>leftmost_lanelet</code> This function returns the Lanelet which is recursively left adjacent to the input Lanelet. \\(O(W)\\) where \\(W\\) is the size of the <code>bundle</code>. In the first and second map, the green Lanelet is the <code>leftmost_lanelet</code> of the orange Lanelet.In the third map, the <code>leftmost_lanelet</code> of the orange Lanelet is <code>null</code>.Open <code>rightmost_lanelet</code> This function returns the Lanelet which is recursively right adjacent to the input Lanelet. \\(O(W)\\) where \\(W\\) is the size of the <code>bundle</code>. In the first map, the green Lanelet is the <code>rightmost_lanelet</code> of the orange Lanelet.In the second and third map, the <code>rightmost_lanelet</code> of the orange Lanelet is <code>null</code>.Open <code>left_lanelets</code> The input Lanelet is not included in the output, and output is ordered from left to right. \\(O(W)\\) where \\(W\\) is the size of the <code>bundle</code>. In the first map, the green Lanelets are the <code>left_lanelets</code> of the orange Lanelet.In the second and third map, <code>left_lanelets</code> of the orange Lanelet is empty.If the flag <code>include_opposite = true</code>, the left opposite Lanelet and all of its <code>same_direction</code> Lanelets area also retrieved as illustrated in the fourth and fifth maps.Open <code>right_lanelets</code> The input Lanelet is not included in the output, and output is ordered from right to left. \\(O(W)\\) where \\(W\\) is the size of the <code>bundle.</code> In the first map, the green Lanelets are the <code>right_lanelets</code> of the orange Lanelet.In the second and third map, <code>right_lanelets</code> of the orange Lanelet is empty.If the flag <code>include_opposite = true</code>, the right opposite Lanelet and all of its <code>same_direction</code> Lanelets area also retrieved as illustrated in the fourth and fifth maps.Open <code>following_lanelets</code> This function returns the <code>following</code> Lanelets of the input Lanelet. The order is not defined. \\(O(E)\\) where \\(E\\) is the number of Lanelets to which the input is connected to. <code>previous_lanelets</code> This function returns the <code>previous</code> Lanelets of the input Lanelet. The order is not defined. \\(O(E)\\) where \\(E\\) is the number of Lanelets from which the input is connected from. <code>sibling_lanelets</code> This function returns the <code>sibling</code> Lanelets of the input Lanelet excluding itself. The order is not defined. \\(O(E)\\) where \\(E\\) is the number of sibling Lanelets <code>from_ids</code> This function returns Lanelet objects in the same order as the input IDs. \\(O(n)\\) <code>&lt;autoware_lanelet2_utils/intersection.hpp&gt;</code> <code>is_intersection_lanelet</code> This function returns <code>true</code> if and only if the input Lanelet has <code>turn_direction</code> attribute. \\(O(1)\\) <code>is_straight_lanelet</code>,<code>is_left_lanelet</code>,<code>is_right_lanelet</code> This function returns <code>true</code> if and only if the input Lanelet has <code>turn_direction</code> attribute and its value is <code>straight</code>/<code>left</code>/<code>right</code>. \\(O(1)\\)"},{"location":"common/autoware_lanelet2_utils/#complexity-of-findusage","title":"complexity of <code>findUsage</code>","text":"<p>The readers should be noted that following description is implementation dependent.</p> <ul> <li>LaneletMap.h</li> <li>LaneletMap.cpp</li> </ul> <p>Lanelet map primitives(like <code>Lanelet</code>, <code>Area</code>, <code>RegulatoryElement</code>) are stored in several <code>PrimitiveLayer&lt;T&gt;</code> objects according to their types as shown below.</p> lanelet2_core/LaneletMap.h#L375-L438<pre><code>class LaneletMap : public LaneletMapLayers {\npublic:\nusing LaneletMapLayers::LaneletMapLayers;\n&lt;...&gt;\n};\n</code></pre> lanelet2_core/LaneletMap.h#L313-L359<pre><code>class LaneletMapLayers {\n&lt;...&gt;\nLaneletLayer laneletLayer;                      //!&lt; access to the lanelets within this map\nAreaLayer areaLayer;                            //!&lt; access to areas\nRegulatoryElementLayer regulatoryElementLayer;  //!&lt; access to regElems\nPolygonLayer polygonLayer;                      //!&lt; access to the polygons\nLineStringLayer lineStringLayer;                //!&lt; access to the lineStrings\nPointLayer pointLayer;                          //!&lt; access to the points\n};\n</code></pre> lanelet2_core/LaneletMap.h#L285-L303<pre><code>class LaneletLayer : public PrimitiveLayer&lt;Lanelet&gt; {\npublic:\nusing PrimitiveLayer::findUsages;\nLaneletLayer() = default;\n~LaneletLayer() = default;\nLaneletLayer(const LaneletLayer&amp;) = delete;\nLaneletLayer operator=(LaneletLayer&amp;) = delete;\nLanelets findUsages(const RegulatoryElementConstPtr&amp; regElem);\nConstLanelets findUsages(const RegulatoryElementConstPtr&amp; regElem) const;\n&lt;...&gt;\n};\n</code></pre> <p>Each <code>PrimitiveLayer</code> owns a field named <code>tree_</code> that contains a lookup table named <code>usage</code> of type <code>UsageLookup</code>,</p> lanelet2_core/LaneletMap.h#L38-L253<pre><code>template &lt;typename T&gt;\nclass PrimitiveLayer {\npublic:\n&lt;...&gt;\n/**\n   * @brief finds usages of an owned type within this layer\n   *\n   * This is the non-const version to find usages of a primitive in a layer.\n   */\nstd::vector&lt;PrimitiveT&gt; findUsages(const traits::ConstPrimitiveType&lt;traits::OwnedT&lt;PrimitiveT&gt;&gt;&amp; primitive);\n&lt;...&gt;\nstruct Tree;\n// NOLINTNEXTLINE\nstd::unique_ptr&lt;Tree&gt; tree_;  //!&lt; Hides boost trees from you/the compiler\n</code></pre> lanelet2_core/src/LaneletMap.cpp#L277-L308<pre><code>template &lt;typename T&gt;\nstruct PrimitiveLayer&lt;T&gt;::Tree {\nusing TreeNode = std::pair&lt;BoundingBox2d, T&gt;;\nusing RTree = bgi::rtree&lt;TreeNode, bgi::quadratic&lt;16&gt;&gt;;\nstatic TreeNode treeNode(const T&amp; elem) { return {geometry::boundingBox2d(to2D(elem)), elem}; }\n&lt;...&gt;\nRTree rTree;\nUsageLookup&lt;T&gt; usage;\n};\n</code></pre> <p>and <code>UsageLookup</code> contains reference relation between different types as <code>std::unordered_multimap</code>.</p> lanelet2_core/src/LaneletMap.cpp#L259-L270<pre><code>template &lt;&gt;\nstruct UsageLookup&lt;Lanelet&gt; {\nvoid add(Lanelet ll) {\nownedLookup.insert(std::make_pair(ll.leftBound(), ll));\nownedLookup.insert(std::make_pair(ll.rightBound(), ll));\nfor (const auto&amp; elem : ll.regulatoryElements()) {\nregElemLookup.insert(std::make_pair(elem, ll));\n}\n}\nstd::unordered_multimap&lt;ConstLineString3d, Lanelet&gt; ownedLookup;\nstd::unordered_multimap&lt;RegulatoryElementConstPtr, Lanelet&gt; regElemLookup;\n};\n</code></pre> <p>Thus the complexity of <code>findUsage</code> function is equal to that of <code>std::unordered_multimap::equal_range</code> which is \\(O(1)\\).</p> lanelet2_core/src/LaneletMap.cpp#L419-L424<pre><code>template &lt;typename T&gt;\nstd::vector&lt;typename PrimitiveLayer&lt;T&gt;::ConstPrimitiveT&gt; PrimitiveLayer&lt;T&gt;::findUsages(\nconst traits::ConstPrimitiveType&lt;traits::OwnedT&lt;PrimitiveLayer&lt;T&gt;::PrimitiveT&gt;&gt;&amp; primitive) const {\nreturn forEachMatchInMultiMap&lt;traits::ConstPrimitiveType&lt;typename PrimitiveLayer&lt;T&gt;::PrimitiveT&gt;&gt;(\ntree_-&gt;usage.ownedLookup, primitive, [](const auto&amp; elem) { return traits::toConst(elem.second); });\n}\n</code></pre> lanelet2_core/src/LaneletMap.cpp#L165-L169<pre><code>template &lt;typename T, typename MapT, typename KeyT, typename Func&gt;\nstd::vector&lt;T&gt; forEachMatchInMultiMap(const MapT&amp; map, const KeyT&amp; key, Func&amp;&amp; f) {\nauto range = map.equal_range(key);\nreturn utils::transform(range.first, range.second, f);\n}\n</code></pre>"},{"location":"common/autoware_lanelet2_utils/#test-maps","title":"Test maps","text":"<p>All of the maps are in <code>MGRS</code> coordinate. In each map, an anchor point is set to an origin point \\((100.0, 100.0)\\) for simplicity.</p> Map name Origin point id Image <code>road_shoulder/highway.osm</code> <code>1</code> <code>road_shoulder/pudo.osm</code> <code>140</code> <code>intersection/crossing.osm</code> <code>1791</code> <code>dense_centerline/lanelet2_map.osm</code> <code>16</code>"},{"location":"common/autoware_lanelet2_utils/#how-to-craft-test-map","title":"How to craft test map","text":"<p>On the VMB, create the map in MGRS system and save the file as <code>&lt;input_map.osm&gt;</code>. Next, select the point to set as origin, get its <code>&lt;ID&gt;</code> and run</p> <pre><code>ros2 run autoware_lanelet2_utils lanelet_anonymizer.py &lt;input_map.osm&gt; &lt;output_map.osm&gt; &lt;ID&gt;\n</code></pre> <p>Then the coordinate of the specified point is (100, 100) on the loaded map(NOTE: not exactly (0, 0) because MGRS does not any point to have negative coordinate value).</p> <p>By applying <code>lanelet_id_aligner.py</code>, the primitive ids are aligned to start from 1 and increase one-by-one.</p> <pre><code>ros2 run autoware_lanelet2_utils lanelet_id_aligner.py &lt;input_map.osm&gt;\n</code></pre>"},{"location":"common/autoware_motion_utils/","title":"Motion Utils package","text":""},{"location":"common/autoware_motion_utils/#motion-utils-package","title":"Motion Utils package","text":""},{"location":"common/autoware_motion_utils/#definition-of-terms","title":"Definition of terms","text":""},{"location":"common/autoware_motion_utils/#segment","title":"Segment","text":"<p><code>Segment</code> in Autoware is the line segment between two successive points as follows.</p> <p></p> <p>The nearest segment index and nearest point index to a certain position is not always th same. Therefore, we prepare two different utility functions to calculate a nearest index for points and segments.</p>"},{"location":"common/autoware_motion_utils/#nearest-index-search","title":"Nearest index search","text":"<p>In this section, the nearest index and nearest segment index search is explained.</p> <p>We have the same functions for the nearest index search and nearest segment index search. Taking for the example the nearest index search, we have two types of functions.</p> <p>The first function finds the nearest index with distance and yaw thresholds.</p> <pre><code>template &lt;class T&gt;\nsize_t findFirstNearestIndexWithSoftConstraints(\nconst T &amp; points, const geometry_msgs::msg::Pose &amp; pose,\nconst double dist_threshold = std::numeric_limits&lt;double&gt;::max(),\nconst double yaw_threshold = std::numeric_limits&lt;double&gt;::max());\n</code></pre> <p>This function finds the first local solution within thresholds. The reason to find the first local one is to deal with some edge cases explained in the next subsection.</p> <p>There are default parameters for thresholds arguments so that you can decide which thresholds to pass to the function.</p> <ol> <li>When both the distance and yaw thresholds are given.<ul> <li>First, try to find the nearest index with both the distance and yaw thresholds.</li> <li>If not found, try to find again with only the distance threshold.</li> <li>If not found, find without any thresholds.</li> </ul> </li> <li>When only distance are given.<ul> <li>First, try to find the nearest index the distance threshold.</li> <li>If not found, find without any thresholds.</li> </ul> </li> <li>When no thresholds are given.<ul> <li>Find the nearest index.</li> </ul> </li> </ol> <p>The second function finds the nearest index in the lane whose id is <code>lane_id</code>.</p> <pre><code>size_t findNearestIndexFromLaneId(\nconst autoware_internal_planning_msgs::msg::PathWithLaneId &amp; path,\nconst geometry_msgs::msg::Point &amp; pos, const int64_t lane_id);\n</code></pre>"},{"location":"common/autoware_motion_utils/#application-to-various-object","title":"Application to various object","text":"<p>Many node packages often calculate the nearest index of objects. We will explain the recommended method to calculate it.</p>"},{"location":"common/autoware_motion_utils/#nearest-index-for-the-ego","title":"Nearest index for the ego","text":"<p>Assuming that the path length before the ego is short enough, we expect to find the correct nearest index in the following edge cases by <code>findFirstNearestIndexWithSoftConstraints</code> with both distance and yaw thresholds. Blue circles describes the distance threshold from the base link position and two blue lines describe the yaw threshold against the base link orientation. Among points in these cases, the correct nearest point which is red can be found.</p> <p></p> <p>Therefore, the implementation is as follows.</p> <pre><code>const size_t ego_nearest_idx = findFirstNearestIndexWithSoftConstraints(points, ego_pose, ego_nearest_dist_threshold, ego_nearest_yaw_threshold);\nconst size_t ego_nearest_seg_idx = findFirstNearestIndexWithSoftConstraints(points, ego_pose, ego_nearest_dist_threshold, ego_nearest_yaw_threshold);\n</code></pre>"},{"location":"common/autoware_motion_utils/#nearest-index-for-dynamic-objects","title":"Nearest index for dynamic objects","text":"<p>For the ego nearest index, the orientation is considered in addition to the position since the ego is supposed to follow the points. However, for the dynamic objects (e.g., predicted object), sometimes its orientation may be different from the points order, e.g. the dynamic object driving backward although the ego is driving forward.</p> <p>Therefore, the yaw threshold should not be considered for the dynamic object. The implementation is as follows.</p> <pre><code>const size_t dynamic_obj_nearest_idx = findFirstNearestIndexWithSoftConstraints(points, dynamic_obj_pose, dynamic_obj_nearest_dist_threshold);\nconst size_t dynamic_obj_nearest_seg_idx = findFirstNearestIndexWithSoftConstraints(points, dynamic_obj_pose, dynamic_obj_nearest_dist_threshold);\n</code></pre>"},{"location":"common/autoware_motion_utils/#nearest-index-for-traffic-objects","title":"Nearest index for traffic objects","text":"<p>In lanelet maps, traffic objects belong to the specific lane. With this specific lane's id, the correct nearest index can be found.</p> <p>The implementation is as follows.</p> <pre><code>// first extract `lane_id` which the traffic object belong to.\nconst size_t traffic_obj_nearest_idx = findNearestIndexFromLaneId(path_with_lane_id, traffic_obj_pos, lane_id);\nconst size_t traffic_obj_nearest_seg_idx = findNearestSegmentIndexFromLaneId(path_with_lane_id, traffic_obj_pos, lane_id);\n</code></pre>"},{"location":"common/autoware_motion_utils/#for-developers","title":"For developers","text":"<p>Some of the template functions in <code>trajectory.hpp</code> are mostly used for specific types (<code>autoware_planning_msgs::msg::PathPoint</code>, <code>autoware_planning_msgs::msg::PathPoint</code>, <code>autoware_planning_msgs::msg::TrajectoryPoint</code>), so they are exported as <code>extern template</code> functions to speed-up compilation time.</p> <p><code>autoware_motion_utils.hpp</code> header file was removed because the source files that directly/indirectly include this file took a long time for preprocessing.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/","title":"vehicle utils","text":""},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#vehicle-utils","title":"vehicle utils","text":"<p>Vehicle utils provides a convenient library used to check vehicle status.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#feature","title":"Feature","text":"<p>The library contains following classes.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#vehicle_stop_checker","title":"vehicle_stop_checker","text":"<p>This class check whether the vehicle is stopped or not based on localization result.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#subscribed-topics","title":"Subscribed Topics","text":"Name Type Description <code>/localization/kinematic_state</code> <code>nav_msgs::msg::Odometry</code> vehicle odometry"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#parameters","title":"Parameters","text":"Name Type Default Value Explanation <code>velocity_buffer_time_sec</code> double 10.0 odometry buffering time [s]"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#member-functions","title":"Member functions","text":"<pre><code>bool isVehicleStopped(const double stop_duration)\n</code></pre> <ul> <li>Check simply whether the vehicle is stopped based on the localization result.</li> <li>Returns <code>true</code> if the vehicle is stopped, even if system outputs a non-zero target velocity.</li> </ul>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#example-usage","title":"Example Usage","text":"<p>Necessary includes:</p> <pre><code>#include &lt;autoware_utils/vehicle/vehicle_state_checker.hpp&gt;\n</code></pre> <p>1.Create a checker instance.</p> <pre><code>class SampleNode : public rclcpp::Node\n{\npublic:\nSampleNode() : Node(\"sample_node\")\n{\nvehicle_stop_checker_ = std::make_unique&lt;VehicleStopChecker&gt;(this);\n}\n\nstd::unique_ptr&lt;VehicleStopChecker&gt; vehicle_stop_checker_;\n\nbool sampleFunc();\n\n...\n}\n</code></pre> <p>2.Check the vehicle state.</p> <pre><code>bool SampleNode::sampleFunc()\n{\n...\n\nconst auto result_1 = vehicle_stop_checker_-&gt;isVehicleStopped();\n\n...\n\nconst auto result_2 = vehicle_stop_checker_-&gt;isVehicleStopped(3.0);\n\n...\n}\n</code></pre>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#vehicle_arrival_checker","title":"vehicle_arrival_checker","text":"<p>This class check whether the vehicle arrive at stop point based on localization and planning result.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#subscribed-topics_1","title":"Subscribed Topics","text":"Name Type Description <code>/localization/kinematic_state</code> <code>nav_msgs::msg::Odometry</code> vehicle odometry <code>/planning/scenario_planning/trajectory</code> <code>autoware_planning_msgs::msg::Trajectory</code> trajectory"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#parameters_1","title":"Parameters","text":"Name Type Default Value Explanation <code>velocity_buffer_time_sec</code> double 10.0 odometry buffering time [s] <code>th_arrived_distance_m</code> double 1.0 threshold distance to check if vehicle has arrived at target point [m]"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#member-functions_1","title":"Member functions","text":"<pre><code>bool isVehicleStopped(const double stop_duration)\n</code></pre> <ul> <li>Check simply whether the vehicle is stopped based on the localization result.</li> <li>Returns <code>true</code> if the vehicle is stopped, even if system outputs a non-zero target velocity.</li> </ul> <pre><code>bool isVehicleStoppedAtStopPoint(const double stop_duration)\n</code></pre> <ul> <li>Check whether the vehicle is stopped at stop point based on the localization and planning result.</li> <li>Returns <code>true</code> if the vehicle is not only stopped but also arrived at stop point.</li> </ul>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#example-usage_1","title":"Example Usage","text":"<p>Necessary includes:</p> <pre><code>#include &lt;autoware_utils/vehicle/vehicle_state_checker.hpp&gt;\n</code></pre> <p>1.Create a checker instance.</p> <pre><code>class SampleNode : public rclcpp::Node\n{\npublic:\nSampleNode() : Node(\"sample_node\")\n{\nvehicle_arrival_checker_ = std::make_unique&lt;VehicleArrivalChecker&gt;(this);\n}\n\nstd::unique_ptr&lt;VehicleArrivalChecker&gt; vehicle_arrival_checker_;\n\nbool sampleFunc();\n\n...\n}\n</code></pre> <p>2.Check the vehicle state.</p> <pre><code>bool SampleNode::sampleFunc()\n{\n...\n\nconst auto result_1 = vehicle_arrival_checker_-&gt;isVehicleStopped();\n\n...\n\nconst auto result_2 = vehicle_arrival_checker_-&gt;isVehicleStopped(3.0);\n\n...\n\nconst auto result_3 = vehicle_arrival_checker_-&gt;isVehicleStoppedAtStopPoint();\n\n...\n\nconst auto result_4 = vehicle_arrival_checker_-&gt;isVehicleStoppedAtStopPoint(3.0);\n\n...\n}\n</code></pre>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p><code>vehicle_stop_checker</code> and <code>vehicle_arrival_checker</code> cannot check whether the vehicle is stopped more than <code>velocity_buffer_time_sec</code> second.</p>"},{"location":"common/autoware_node/","title":"Autoware Node","text":""},{"location":"common/autoware_node/#autoware-node","title":"Autoware Node","text":""},{"location":"common/autoware_node/#abbreviations","title":"Abbreviations","text":"<ul> <li>AN: Autoware Node</li> </ul>"},{"location":"common/autoware_node/#overview","title":"Overview","text":"<p>AN is an <code>autoware_core</code> package designed to provide a base class for all future nodes in the system.</p>"},{"location":"common/autoware_node/#usage","title":"Usage","text":"<p>Check the autoware_test_node package for an example of how to use <code>autoware::Node</code>.</p>"},{"location":"common/autoware_object_recognition_utils/","title":"autoware_object_recognition_utils","text":""},{"location":"common/autoware_object_recognition_utils/#autoware_object_recognition_utils","title":"autoware_object_recognition_utils","text":""},{"location":"common/autoware_object_recognition_utils/#overview","title":"Overview","text":"<p>This package contains a library of common functions that are useful across the perception module and planning module.</p>"},{"location":"common/autoware_object_recognition_utils/#design","title":"Design","text":""},{"location":"common/autoware_object_recognition_utils/#conversion","title":"Conversion","text":"<p>Ensuring accurate and efficient converting between DetectedObject and TrackedObject types.</p>"},{"location":"common/autoware_object_recognition_utils/#geometry","title":"Geometry","text":"<p>It provides specialized implementations for each object type (e.g., DetectedObject, TrackedObject, and PredictedObject) to extract the pose information.</p>"},{"location":"common/autoware_object_recognition_utils/#matching","title":"Matching","text":"<p>It provides utility functions for calculating geometrical metrics, such as 2D IoU (Intersection over Union), GIoU (Generalized IoU), Precision, and Recall for objects. It also provides helper functions for computing areas of intersections, unions, and convex hulls of polygon</p>"},{"location":"common/autoware_object_recognition_utils/#object-classification","title":"Object Classification","text":"<p>Designed for processing and classifying detected objects, it implements the following functionalities:</p> <ul> <li>Handling of vehicle category checks</li> <li>Conversion between string class names and numerical labels</li> <li>Probability-based classification selection</li> <li>String representation of object labels</li> </ul>"},{"location":"common/autoware_object_recognition_utils/#predicted-path-utils","title":"Predicted Path Utils","text":"<p>Providing utility functions for handling predicted paths of objects. It includes the following functionalities:</p> <ul> <li>calcInterpolatedPose: Calculates an interpolated pose from a predicted path based on a given time.</li> <li>resamplePredictedPath (version 1): Resamples a predicted path according to a specified time vector, optionally using spline interpolation for smoother results.</li> <li>resamplePredictedPath (version 2): Resamples a predicted path at regular time intervals, including the terminal point, with optional spline interpolation.</li> </ul>"},{"location":"common/autoware_object_recognition_utils/#usage","title":"Usage","text":"<p>include all-in-one header files if multiple functionalities are needed:</p> <pre><code>#include &lt;autoware_object_recognition_utils/object_recognition_utils.hpp&gt;\n</code></pre> <p>include specific header files if only a subset of functionalities is needed:</p> <pre><code>#include &lt;autoware_object_recognition_utils/object_classifier.hpp&gt;\n</code></pre>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/","title":"Interface for the OSQP library","text":""},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#interface-for-the-osqp-library","title":"Interface for the OSQP library","text":"<p>This is the design document for the <code>autoware_osqp_interface</code> package.</p>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#purpose-use-cases","title":"Purpose / Use cases","text":"<p>This packages provides a C++ interface for the OSQP library.</p>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#design","title":"Design","text":"<p>The class <code>OSQPInterface</code> takes a problem formulation as Eigen matrices and vectors, converts these objects into C-style Compressed-Column-Sparse matrices and dynamic arrays, loads the data into the OSQP workspace dataholder, and runs the optimizer.</p>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#inputs-outputs-api","title":"Inputs / Outputs / API","text":"<p>The interface can be used in several ways:</p> <ol> <li> <p>Initialize the interface WITHOUT data. Load the problem formulation at the optimization call.</p> <pre><code>    osqp_interface = OSQPInterface();\nosqp_interface.optimize(P, A, q, l, u);\n</code></pre> </li> <li> <p>Initialize the interface WITH data.</p> <pre><code>    osqp_interface = OSQPInterface(P, A, q, l, u);\nosqp_interface.optimize();\n</code></pre> </li> <li> <p>WARM START OPTIMIZATION by modifying the problem formulation between optimization runs.</p> <pre><code>    osqp_interface = OSQPInterface(P, A, q, l, u);\nosqp_interface.optimize();\nosqp.initializeProblem(P_new, A_new, q_new, l_new, u_new);\nosqp_interface.optimize();\n</code></pre> <p>The optimization results are returned as a vector by the optimization function.</p> <pre><code>std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; result = osqp_interface.optimize();\nstd::vector&lt;double&gt; param = result.primal_solution;\ndouble x_0 = param[0];\ndouble x_1 = param[1];\n</code></pre> </li> </ol>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#references-external-links","title":"References / External links","text":"<ul> <li>OSQP library: https://osqp.org/</li> </ul>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#related-issues","title":"Related issues","text":""},{"location":"common/autoware_point_types/","title":"Autoware Point Types","text":""},{"location":"common/autoware_point_types/#autoware-point-types","title":"Autoware Point Types","text":""},{"location":"common/autoware_point_types/#overview","title":"Overview","text":"<p>This package provides a variety of structures to represent different types of point cloud data, mainly used for point cloud processing and analysis.</p>"},{"location":"common/autoware_point_types/#design","title":"Design","text":""},{"location":"common/autoware_point_types/#point-cloud-data-type-definition","title":"Point cloud data type definition","text":"<p><code>autoware_point_types</code> defines multiple structures (such as PointXYZI, PointXYZIRC, PointXYZIRADRT, PointXYZIRCAEDT), each structure contains different attributes to adapt to different application scenarios.</p> <ul> <li><code>autoware::point_types::PointXYZI</code>: Point type with intensity information.</li> <li><code>autoware::point_types::PointXYZIRC</code>: Extended PointXYZI, adds return_type and channel information.</li> <li><code>autoware::point_types::PointXYZIRADRT</code>: Extended PointXYZI, adds ring, azimuth, distance, return_type and time_stamp information.</li> <li><code>autoware::point_types::PointXYZIRCAEDT</code>: Similar to PointXYZIRADRT, but adds elevation information and uses <code>std::uint32_t</code> as the data type for time_stamp.</li> </ul>"},{"location":"common/autoware_point_types/#operator-overload","title":"Operator overload","text":"<p>Each structure overloads the <code>==</code> operator, allowing users to easily compare whether two points are equal, which is very useful for deduplication and matching of point cloud data.</p>"},{"location":"common/autoware_point_types/#field-generators","title":"Field generators","text":"<p>The field generator is implemented using macro definitions and std::tuple, which simplifies the serialization and deserialization process of point cloud messages and improves the reusability and readability of the code.</p>"},{"location":"common/autoware_point_types/#registration-mechanism","title":"Registration mechanism","text":"<p>Register custom point cloud structures into the PCL library through the macro <code>POINT_CLOUD_REGISTER_POINT_STRUCT</code>, so that these structures can be directly integrated with other functions of the PCL library.</p>"},{"location":"common/autoware_point_types/#usage","title":"Usage","text":"<ul> <li>Create a point cloud object of PointXYZIRC type</li> </ul> <pre><code>#include \"autoware/point_types/types.hpp\"\n\nint main(){\npcl::PointCloud&lt;autoware::point_types::PointXYZIRC&gt;::Ptr cloud(new pcl::PointCloud&lt;autoware::point_types::PointXYZIRC&gt;());\n\nfor (int i = 0; i &lt; 5; ++i) {\nautoware::point_types::PointXYZIRC point;\npoint.x = static_cast&lt;float&gt;(i * 0.1);\npoint.y = static_cast&lt;float&gt;(i * 0.2);\npoint.z = static_cast&lt;float&gt;(i * 0.3);\npoint.intensity = static_cast&lt;std::uint8_t&gt;(i * 10);\npoint.return_type = autoware::point_types::ReturnType::SINGLE_STRONGEST;\npoint.channel = static_cast&lt;std::uint16_t&gt;(i);\n\ncloud-&gt;points.push_back(point);\n}\ncloud-&gt;width = cloud-&gt;points.size();\ncloud-&gt;height = 1;\n\nreturn 0;\n}\n</code></pre> <ul> <li>Convert ROS message to point cloud of PointXYZIRC type</li> </ul> <pre><code>ExampleNode::points_callback(const PointCloud2::ConstSharedPtr &amp; points_msg_ptr)\n{\npcl::PointCloud&lt;autoware::point_types::PointXYZIRC&gt;::Ptr points_ptr(\nnew pcl::PointCloud&lt;autoware::point_types::PointXYZIRC&gt;);\n\npcl::fromROSMsg(*points_msg_ptr, *points_ptr);\n}\n</code></pre>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/","title":"Interface for QP solvers","text":""},{"location":"common/autoware_qp_interface/design/qp_interface-design/#interface-for-qp-solvers","title":"Interface for QP solvers","text":"<p>This is the design document for the <code>autoware_qp_interface</code> package.</p>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#purpose-use-cases","title":"Purpose / Use cases","text":"<p>This packages provides a C++ interface for QP solvers. Currently, supported QP solvers are</p> <ul> <li>OSQP library</li> </ul>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#design","title":"Design","text":"<p>The class <code>QPInterface</code> takes a problem formulation as Eigen matrices and vectors, converts these objects into C-style Compressed-Column-Sparse matrices and dynamic arrays, loads the data into the QP workspace dataholder, and runs the optimizer.</p>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#inputs-outputs-api","title":"Inputs / Outputs / API","text":"<p>The interface can be used in several ways:</p> <ol> <li> <p>Initialize the interface, and load the problem formulation at the optimization call.</p> <pre><code>    QPInterface qp_interface;\nqp_interface.optimize(P, A, q, l, u);\n</code></pre> </li> <li> <p>WARM START OPTIMIZATION by modifying the problem formulation between optimization runs.</p> <pre><code>    QPInterface qp_interface(true);\nqp_interface.optimize(P, A, q, l, u);\nqp_interface.optimize(P_new, A_new, q_new, l_new, u_new);\n</code></pre> <p>The optimization results are returned as a vector by the optimization function.</p> <pre><code>const auto solution = qp_interface.optimize();\ndouble x_0 = solution[0];\ndouble x_1 = solution[1];\n</code></pre> </li> </ol>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#references-external-links","title":"References / External links","text":"<ul> <li>OSQP library: https://osqp.org/</li> </ul>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#related-issues","title":"Related issues","text":""},{"location":"common/autoware_signal_processing/","title":"Signal Processing Methods","text":""},{"location":"common/autoware_signal_processing/#signal-processing-methods","title":"Signal Processing Methods","text":"<p>In this package, we present signal processing related methods for the Autoware applications. The following functionalities are available in the current version.</p> <ul> <li>an 1-D Low-pass filter,</li> <li>Butterworth low-pass filter tools.</li> </ul> <p>low-pass filter currently supports only the 1-D low pass filtering.</p>"},{"location":"common/autoware_signal_processing/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p>TBD.</p>"},{"location":"common/autoware_signal_processing/documentation/ButterworthFilter/","title":"ButterworthFilter","text":""},{"location":"common/autoware_signal_processing/documentation/ButterworthFilter/#butterworth-low-pass-filter-design-tool-class","title":"Butterworth Low-pass Filter Design Tool Class","text":"<p>This Butterworth low-pass filter design tool can be used to design a Butterworth filter in continuous and discrete-time from the given specifications of the filter performance. The Butterworth filter is a class implementation. A default constructor creates the object without any argument.</p> <p>The filter can be prepared in three ways. If the filter specifications are known, such as the pass-band, and stop-band frequencies (Wp and Ws) together with the pass-band and stop-band ripple magnitudes (Ap and As), one can call the filter's buttord method with these arguments to obtain the recommended filter order (N) and cut-off frequency (Wc_rad_sec [rad/s]).</p> <p> Figure 1. Butterworth Low-pass filter specification from [1].</p> <p>An example call is demonstrated below;</p> <pre><code>ButterworthFilter bf();\n\nWp = 2.0; // pass-band frequency [rad/sec]\nWs = 3.0; // stop-band frequency [rad/sec]\nAp = 6.0; // pass-band ripple mag or loss [dB]\nAs = 20.0; // stop band ripple attenuation [dB]\n\n// Computing filter coefficients from the specs\nbf.Buttord(Wp, Ws, Ap, As);\n\n// Get the computed order and Cut-Off frequency\nsOrderCutOff NWc = bf.getOrderCutOff();]\n\ncout &lt;&lt; \" The computed order is ;\" &lt;&lt; NWc.N &lt;&lt; endl;\ncout &lt;&lt; \" The computed cut-off frequency is ;\" &lt;&lt; NWc.Wc_rad_sec &lt;&lt; endl;\n</code></pre> <p>The filter order and cut-off frequency can be obtained in a struct using bf.getOrderCutoff() method. These specs can be printed on the screen by calling PrintFilterSpecs() method. If the user would like to define the order and cut-off frequency manually, the setter methods for these variables can be called to set the filter order (N) and the desired cut-off frequency (Wc_rad_sec [rad/sec]) for the filter.</p>"},{"location":"common/autoware_signal_processing/documentation/ButterworthFilter/#obtaining-filter-transfer-functions","title":"Obtaining Filter Transfer Functions","text":"<p>The discrete transfer function of the filter requires the roots and gain of the continuous-time transfer function. Therefore, it is a must to call the first computeContinuousTimeTF() to create the continuous-time transfer function of the filter using;</p> <pre><code>bf.computeContinuousTimeTF();\n</code></pre> <p>The computed continuous-time transfer function roots can be printed on the screen using the methods;</p> <pre><code>bf.PrintFilter_ContinuousTimeRoots();\nbf.PrintContinuousTimeTF();\n</code></pre> <p>The resulting screen output for a 5th order filter is demonstrated below.</p> <pre><code> Roots of Continuous Time Filter Transfer Function Denominator are :\n-0.585518 + j 1.80204\n-1.53291 + j 1.11372\n-1.89478 + j 2.32043e-16\n-1.53291 + j -1.11372\n-0.585518 + j -1.80204\n\n\nThe Continuous-Time Transfer Function of the Filter is ;\n\n                                   24.422\n-------------------------------------------------------------------------------\n1.000 *s[5] + 6.132 *s[4] + 18.798 *s[3] + 35.619 *s[2] + 41.711 *s[1] + 24.422\n</code></pre>"},{"location":"common/autoware_signal_processing/documentation/ButterworthFilter/#discrete-time-transfer-function-difference-equations","title":"Discrete Time Transfer Function (Difference Equations)","text":"<p>The digital filter equivalent of the continuous-time definitions is produced by using the bi-linear transformation. When creating the discrete-time function of the ButterworthFilter object, its Numerator (Bn) and Denominator (An ) coefficients are stored in a vector of filter order size N.</p> <p>The discrete transfer function method is called using ;</p> <pre><code>bf.computeDiscreteTimeTF();\nbf.PrintDiscreteTimeTF();\n</code></pre> <p>The results are printed on the screen like; The Discrete-Time Transfer Function of the Filter is ;</p> <pre><code>0.191 *z[-5] + 0.956 *z[-4] + 1.913 *z[-3] + 1.913 *z[-2] + 0.956 *z[-1] + 0.191\n--------------------------------------------------------------------------------\n1.000 *z[-5] + 1.885 *z[-4] + 1.888 *z[-3] + 1.014 *z[-2] + 0.298 *z[-1] + 0.037\n</code></pre> <p>and the associated difference coefficients An and Bn by withing a struct ;</p> <pre><code>sDifferenceAnBn AnBn = bf.getAnBn();\n</code></pre> <p>The difference coefficients appear in the filtering equation in the form of.</p> <pre><code>An * Y_filtered = Bn * Y_unfiltered\n</code></pre> <p>To filter a signal given in a vector form ;</p>"},{"location":"common/autoware_signal_processing/documentation/ButterworthFilter/#calling-filter-by-a-specified-cut-off-and-sampling-frequencies-in-hz","title":"Calling Filter by a specified cut-off and sampling frequencies [in Hz]","text":"<p>The Butterworth filter can also be created by defining the desired order (N), a cut-off frequency (fc in [Hz]), and a sampling frequency (fs in [Hz]). In this method, the cut-off frequency is pre-warped with respect to the sampling frequency [1, 2] to match the continuous and digital filter frequencies.</p> <p>The filter is prepared by the following calling options;</p> <pre><code> // 3rd METHOD defining a sampling frequency together with the cut-off fc, fs\n bf.setOrder(2);\n bf.setCutOffFrequency(10, 100);\n</code></pre> <p>At this step, we define a boolean variable whether to use the pre-warping option or not.</p> <pre><code>// Compute Continuous Time TF\nbool use_sampling_frequency = true;\nbf.computeContinuousTimeTF(use_sampling_frequency);\nbf.PrintFilter_ContinuousTimeRoots();\nbf.PrintContinuousTimeTF();\n\n// Compute Discrete Time TF\nbf.computeDiscreteTimeTF(use_sampling_frequency);\nbf.PrintDiscreteTimeTF();\n</code></pre> <p>References:</p> <ol> <li> <p>Manolakis, Dimitris G., and Vinay K. Ingle. Applied digital signal processing: theory and practice. Cambridge    University Press, 2011.</p> </li> <li> <p>https://en.wikibooks.org/wiki/Digital_Signal_Processing/Bilinear_Transform</p> </li> </ol>"},{"location":"common/autoware_trajectory/","title":"Autoware Trajectory","text":""},{"location":"common/autoware_trajectory/#autoware-trajectory","title":"Autoware Trajectory","text":"<p>This package provides classes to manage/manipulate Trajectory.</p>"},{"location":"common/autoware_trajectory/#overview","title":"Overview","text":""},{"location":"common/autoware_trajectory/#interpolators","title":"Interpolators","text":"<p>The interpolator class interpolates given <code>bases</code> and <code>values</code>. Following interpolators are implemented.</p> <ul> <li>Linear</li> <li>AkimaSpline</li> <li>CubicSpline</li> <li>NearestNeighbor</li> <li>Stairstep</li> </ul> <p> View in Drawio</p> <p>The builder internally executes interpolation and return the result in the form of <code>expected&lt;T, E&gt;</code>. If successful, it contains the interpolator object.</p> ./examples/example_readme.cpp:53:68<pre><code>  std::vector&lt;double&gt; xs = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};\nstd::vector&lt;double&gt; ys = {0.0 + noise(), 1.0 + noise(), 2.0 + noise(),\n3.0 + noise(), 4.0 + noise(), 5.0 + noise()};\n\n// You need to use the `Builder` to try to construct the interpolator\nconst tl::expected&lt;CubicSpline, InterpolationFailure&gt; result =\nCubicSpline::Builder()\n.set_bases(xs)   // set the base\n.set_values(ys)  // set the value\n.build();        // finally, call build()\n\n// The result may be `InterpolationFailure` type if the input is not suitable\n// for this interpolator\nif (!result) {\nreturn 0;\n}\n</code></pre> <p>Otherwise it contains the error object representing the failure reason. In the below snippet, cubic spline interpolation fails because the number of input points is 3, which is below the <code>minimum_required_points() = 4</code> of <code>CubicSpline</code>.</p> ./examples/example_readme.cpp:109:119<pre><code>  // Give only 3 points for CubicSpline, which is infeasible\nstd::vector&lt;double&gt; xs = {0.0, 1.0, 2.0};\nstd::vector&lt;double&gt; ys = {0.0 + noise(), 1.0 + noise(), 2.0 + noise()};\n\n// You need to use the `Builder` to try to construct the interpolator\nconst tl::expected&lt;CubicSpline, InterpolationFailure&gt; result =\nCubicSpline::Builder()\n.set_bases(xs)   // set the base\n.set_values(ys)  // set the value\n.build();        // finally, call build()\n</code></pre> <p>In such cases the result <code>expected</code> object contains <code>InterpolationFailure</code> type with an error message like \"base size 3 is less than minimum required 4\".</p>"},{"location":"common/autoware_trajectory/#trajectory-class","title":"Trajectory class","text":"<p>The Trajectory class provides mathematical continuous representation and object oriented interface for discrete array of following point types</p> <ul> <li> <code>geometry_msgs::Point</code></li> <li> <code>geometry_msgs::Pose</code></li> <li> <code>autoware_planning_msgs::PathPoint</code></li> <li> <code>autoware_planning_msgs::PathPointWithLaneId</code></li> <li> <code>autoware_planning_msgs::TrajectoryPoint</code></li> <li> <code>lanelet::ConstPoint3d</code></li> </ul> <p>by interpolating the given underlying points. Once built, arbitrary point on the curve is continuously parametrized by a single <code>s</code> coordinate.</p> ./examples/example_readme.cpp:547:562<pre><code>  };\n\nstd::vector&lt;geometry_msgs::msg::Point&gt; underlying_points = {\npose(0.49, 0.59), pose(1.20, 2.56), pose(1.51, 3.17), pose(1.85, 3.76),\npose(2.60, 4.56), pose(3.61, 4.30), pose(3.95, 4.01), pose(4.90, 3.25),\npose(5.54, 3.10), pose(6.88, 3.54), pose(7.85, 4.93), pose(8.03, 5.73),\npose(8.16, 6.52), pose(8.68, 8.45), pose(8.96, 8.96), pose(9.32, 9.36)};\nauto result = Trajectory&lt;geometry_msgs::msg::Point&gt;::Builder{}.build(underlying_points);\nif (!result) {\nstd::cout &lt;&lt; result.error().what &lt;&lt; std::endl;\nreturn 0;\n}\nauto &amp; trajectory = result.value();\nconst auto s = trajectory.base_arange(0.05);  // cppcheck-suppress shadowVariable\nconst auto C = trajectory.compute(s);\nconst auto Cx = C | transform([&amp;](const auto &amp; p) { return p.x; }) | to&lt;std::vector&gt;();\n</code></pre> <p> View in Drawio</p>"},{"location":"common/autoware_trajectory/#nomenclature","title":"Nomenclature","text":"<p>This section introduces strict definition of several words used in this package to clarify the description of API and help the developers understand and grasp the geometric meaning of algorithms.</p> Word Meaning Illustration <code>curve</code> <code>curve</code> is an oriented bounded curve denoted as <code>(x(s), y(s), z(s))</code> with additional properties, parameterized by <code>s</code> (<code>s = 0</code> at the start). View in DrawioThere are 5 <code>underlying</code> points\\(\\mathrm{P0} = (0, 0, 0)\\)\\(\\mathrm{P1} = (1/ \\sqrt{2}, 1/ \\sqrt{2}, 0)\\)\\(\\mathrm{P2} = (1/ \\sqrt{2}, 1+1/ \\sqrt{2}, 0)\\)\\(\\mathrm{P3} = (2/ \\sqrt{2}, 1+2/ \\sqrt{2}, 0)\\)\\(\\mathrm{P4} = (2/ \\sqrt{2} + 1/ \\sqrt{6}, 1+2/ \\sqrt{2} + 1 / \\sqrt{3}, 1 / \\sqrt{2})\\)and the <code>arc length</code> between each interval is \\(1, 2, 1, 1\\) respectively, so \\(\\mathrm{start} = 0\\) and \\(\\mathrm{end} = 5\\). <code>underlying</code> <code>underlying</code> points of a curve refers to the list of 3D points from which the curve was interpolated. <code>arc length</code>[m] <code>arc length</code> denotes the approximate 3D length of of a curve and is computed based on the discrete <code>underlying</code> points. <code>s</code>[m] <code>s</code> denotes the 3D <code>arc length</code> coordinate starting from the base point (mostly the start point) of the curve and a point is identified by <code>trajectory(s)</code>.Due to this definition, the actual curve length and <code>arc length</code> have subtle difference as illustrated. View in DrawioThe point for \\(s = 0.5\\) is the purple dot, but the curve length from \\(\\mathrm{P0}\\) to this point does not equal to \\(0.5\\).The exact curve length is \\(\\int \\sqrt{(\\frac{dx}{dt})^2 + (\\frac{dy}{dt})^2 + (\\frac{dz}{dt})^2} dt\\), which cannot be obtained in an analytical closed form. <code>curvature</code> <code>curvature</code> is computed using only X-Y 2D coordinate. This is based on the normal and natural assumption that roads are flat. Mathematically, it asserts that Gaussian curvature of road is uniformly 0.The sign of curvature is positive if the center of turning circle is on the left side, otherwise negative. View in Drawio <code>k_points_minimum_dist_threshold</code> This is a constant threshold that is used to check if two points or values are same and to avoid zero division. <code>almost-same</code> The pair of two points \\(P_{1}\\) and \\(P_{2}\\), or the pair of two base values \\(s_{1}\\) and \\(s_{2}\\) are called <code>almost-same</code> if their distance or difference are less than <code>k_points_minimum_dist_threshold</code>"},{"location":"common/autoware_trajectory/#api","title":"API","text":""},{"location":"common/autoware_trajectory/#interpolators_1","title":"Interpolators","text":"Class method/function description Common Functions <code>minimum_required_points()</code> return the number of points required for each concrete interpolator <code>compute(double s) -&gt; T</code> compute the interpolated value at given base \\(s\\). \\(s\\) is clamped to the underlying base range. <code>compute(vector&lt;double&gt; s) -&gt; vector&lt;T&gt;</code> compute the interpolated values at for each base values in \\(s\\). <code>compute_first_derivative(double s) -&gt; double</code> compute the first derivative of at given base \\(s\\). \\(s\\) is clamped. <code>compute_second_derivative(double s) -&gt; double</code> compute the second derivative of at given base \\(s\\). \\(s\\) is clamped. <p><code>AkimaSpline</code> requires at least 5 points to interpolate.</p> ./examples/example_readme.cpp:137:151<pre><code>  auto &amp; ax2 = axes[1];\n\nusing autoware::experimental::trajectory::interpolator::AkimaSpline;\nusing autoware::experimental::trajectory::interpolator::InterpolationFailure;\n\nstd::vector&lt;double&gt; xs = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};\nstd::vector&lt;double&gt; ys = {0.0 + noise(), 1.0 + noise(), 2.0 + noise(),\n3.0 + noise(), 4.0 + noise(), 5.0 + noise()};\n\n// You need to use the `Builder` to try to construct the interpolator\nconst tl::expected&lt;AkimaSpline, InterpolationFailure&gt; result =\nAkimaSpline::Builder()\n.set_bases(xs)   // set the base\n.set_values(ys)  // set the value\n.build();        // finally, call build()\n</code></pre> <p> View in Drawio</p> <p><code>CubicSpline</code> requires at least 4 points to interpolate.</p> ./examples/example_readme.cpp:192:201<pre><code>  std::vector&lt;double&gt; xs = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};\nstd::vector&lt;double&gt; ys = {0.0 + noise(), 1.0 + noise(), 2.0 + noise(),\n3.0 + noise(), 4.0 + noise(), 5.0 + noise()};\n\n// You need to use the `Builder` to try to construct the interpolator\nconst tl::expected&lt;CubicSpline, InterpolationFailure&gt; result =\nCubicSpline::Builder()\n.set_bases(xs)   // set the base\n.set_values(ys)  // set the value\n.build();        // finally, call build()\n</code></pre> <p> View in Drawio</p> <p><code>Linear</code> requires at least 2 points to interpolate.</p> ./examples/example_readme.cpp:242:250<pre><code>  std::vector&lt;double&gt; xs = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};\nstd::vector&lt;double&gt; ys = {0.0 + noise(), 1.0 + noise(), 2.0 + noise(),\n3.0 + noise(), 4.0 + noise(), 5.0 + noise()};\n\n// You need to use the `Builder` to try to construct the interpolator\nconst tl::expected&lt;Linear, InterpolationFailure&gt; result = Linear::Builder()\n.set_bases(xs)   // set the base\n.set_values(ys)  // set the value\n.build();  // finally, call build()\n</code></pre> <p> View in Drawio</p> <p><code>StairStep</code> requires at least 2 points to interpolate.</p> ./examples/example_readme.cpp:291:300<pre><code>  std::vector&lt;double&gt; xs = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};\nstd::vector&lt;double&gt; ys = {0.0 + noise(), 1.0 + noise(), 2.0 + noise(),\n3.0 + noise(), 4.0 + noise(), 5.0 + noise()};\n\n// You need to use the `Builder` to try to construct the interpolator\nconst tl::expected&lt;Stairstep&lt;double&gt;, InterpolationFailure&gt; result =\nStairstep&lt;double&gt;::Builder()\n.set_bases(xs)   // set the base\n.set_values(ys)  // set the value\n.build();        // finally, call build()\n</code></pre> <p> View in Drawio</p>"},{"location":"common/autoware_trajectory/#trajectory-class_1","title":"Trajectory class","text":"<p>Several <code>Trajectory&lt;T&gt;</code> are defined in the following inheritance hierarchy according to the sub object relationships.</p> <p> View in Drawio</p> <p>Each derived class in the diagram inherits the methods of all of its descending subclasses. For example, all of the classes have the methods like <code>length()</code>, <code>curvature()</code> in common.</p> Header/Class method description illustration <code>&lt;autoware/trajectory/point.hpp&gt;</code><ul><li><code>Trajectory&lt;geometry_msgs::msg::Point&gt;::Builder</code></li></ul> <code>Builder()</code> set default interpolator setting as follows.<ul><li><code>x, y</code>: Cubic</li><li><code>z</code>: Linear</li></ul> <code>set_xy_interpolator&lt;InterpolatorType&gt;()</code> set custom interpolator for <code>x, y</code>. <code>set_z_interpolator&lt;InterpolatorType&gt;()</code> set custom interpolator for <code>z</code>. <code>build(const vector&lt;Point&gt; &amp;)</code> return <code>expected&lt;Trajectory&lt;Point&gt;, InterpolationFailure&gt;</code> object. <ul><li><code>Trajectory&lt;Point&gt;</code></li></ul> <code>base_arange(const double step)</code> return vector of <code>s</code> values starting from <code>start</code>, with the interval of <code>step</code>, including <code>end</code>. Thus the return value has at least the size of 2. <code>length()</code> return the total <code>arc length</code> of the trajectory. View in Drawio<code>length()</code> is \\(5.0\\) because it computes the sum of the length of dotted lines. <code>azimuth(const double s)</code> return the tangent angle at given <code>s</code> coordinate using <code>std::atan2</code>. View in Drawio <code>curvature(const double s)</code> return the signed <code>curvature</code> at given <code>s</code> coordinate following \\(\\sqrt{\\dot{x}^2 + \\dot{y}^2}^3 / (\\dot{x}\\ddot{y} - \\dot{y}\\ddot{x})\\). See above <code>elevation(const double s)</code> return the elevation angle at given <code>s</code> coordinate. <code>get_underlying_base()</code> return the vector of <code>s</code> values of current <code>underlying</code> points. <code>&lt;autoware/trajectory/pose.hpp&gt;</code><ul><li><code>Trajectory&lt;geometry_msgs::msg::Pose&gt;::Builder</code></li></ul> <code>Builder()</code> set default interpolator setting in addition to that of <code>Trajectory&lt;Point&gt;::Builder</code> as follows.<ul><li><code>orientation</code>: SphericalLinear</li></ul> <code>set_orientation_interpolator&lt;InterpolatorType&gt;()</code> set custom interpolator for <code>orientation</code>. <code>build(const vector&lt;Pose&gt; &amp;)</code> return <code>expected&lt;Trajectory&lt;Pose&gt;, InterpolationFailure&gt;</code> object. <ul><li><code>Trajectory&lt;Pose&gt;</code></li></ul> derives all of the above methods of <code>Trajectory&lt;Point&gt;</code> <code>align_orientation_with_trajectory_direction()</code> update the underlying points so that their orientations match the <code>azimuth()</code> of interpolated <code>curve</code>. This is useful when the user gave only the position of <code>Pose</code> and created <code>Trajectory</code> object. View in Drawio <code>&lt;autoware/trajectory/path_point.hpp&gt;</code><ul><li><code>Trajectory&lt;autoware_planning_msgs::msg::PathPoint&gt;::Builder</code></li></ul> <code>Builder()</code> set default interpolator setting in addition to that of <code>Trajectory&lt;Pose&gt;::Builder</code> as follows.<ul><li><code>longitudinal_velocity_mps</code>: StairStep</li><li><code>lateral_velocity_mps</code>: StairStep</li><li><code>heading_rate_rps</code>: StairStep</li></ul> <code>set_longitudinal_velocity_mps_interpolator&lt;InterpolatorType&gt;()</code> set custom interpolator for <code>longitudinal_velocity_mps</code>. <code>set_lateral_velocity_mps_interpolator&lt;InterpolatorType&gt;()</code> set custom interpolator for <code>lateral_velocity_mps</code>. <code>set_heading_rate_rps_interpolator&lt;InterpolatorType&gt;()</code> set custom interpolator for <code>heading_rate_rps</code>. <code>build(const vector&lt;PathPoint&gt; &amp;)</code> return <code>expected&lt;Trajectory&lt;PathPoint&gt;, InterpolationFailure&gt;</code> object. <ul><li><code>Trajectory&lt;PathPoint&gt;</code></li></ul> derives all of the above methods of <code>Trajectory&lt;Pose&gt;</code> <code>longitudinal_velocity_mps()</code> return reference to <code>longitudinal_velocity_mps</code> <code>lateral_velocity_mps()</code> return reference to <code>lateral_velocity_mps</code> <code>heading_rate_rps_mps()</code> return reference to <code>heading_rate_rps</code> <code>&lt;autoware/trajectory/path_point_with_lane_id.hpp&gt;</code><ul><li><code>Trajectory&lt;autoware_internal_planning_msgs::msg::PathPointWithLaneId&gt;::Builder</code></li></ul> <code>Builder()</code> set default interpolator setting in addition to that of <code>Trajectory&lt;PathPoint&gt;::Builder</code> as follows.<ul><li><code>lane_ids</code>: StairStep</li></ul> <code>set_lane_ids_interpolator&lt;InterpolatorType&gt;()</code> set custom interpolator for <code>lane_ids</code>. <code>build(const vector&lt;PathPointWithLaneId&gt; &amp;)</code> return <code>expected&lt;Trajectory&lt;PathPointWithLaneId&gt;, InterpolationFailure&gt;</code> object. <ul><li><code>Trajectory&lt;PathPointWithLaneId&gt;</code></li></ul> derives all of the above methods of <code>Trajectory&lt;PathPoint&gt;</code> <code>lane_ids()</code> return reference to <code>lane_ids</code>"},{"location":"common/autoware_trajectory/#utility-functions","title":"Utility functions","text":"Header / function description detail <code>&lt;autoware/trajectory/utils/shift.hpp</code> View in DrawioThis is the case where \\(a_{\\mathrm{max}}^{\\mathrm{lat}} &gt; a_{\\mathrm{lim}}^{\\mathrm{lat}}\\) because newly 4 points are inserted in the shift interval. <ul><li><code>struct ShiftedTrajectory</code></li></ul> contains<ul><li><code>trajectory: Trajectory</code></li><li><code>shift_start_s: double</code></li><li><code>shift_end_s: double</code></li></ul> Returns the shifted trajectory as well the <code>s</code> values indicating where the shift starts and completes on the new shifted trajectory.View in Drawio <ul><li><code>struct ShiftInterval</code></li></ul> contains<ul><li><code>start: double</code></li><li><code>end: double</code></li><li><code>lateral_offset: double</code></li></ul> <ul><li><code>start &lt; end</code> is required.</li><li>If <code>lateral_offset</code> is positive, the path is shifted on the right side, otherwise on the left side.</li></ul>View in Drawio <ul><li><code>struct ShiftParameters</code></li></ul> contains<ul><li><code>velocity: double</code></li><li><code>lateral_acc_limit: double</code></li><li><code>longitudinal_acc: double</code></li></ul> <ul><li><code>velocity</code> needs to be positive.</li></ul> <ul><li><code>shift(const &amp;Trajectory, const &amp;ShiftInterval, const &amp;ShiftParameters) -&gt; expected&lt;ShiftedTrajectory, ShiftError&gt;</code></li></ul> Following formulation, return a shifted <code>Trajectory</code> object if the parameters are feasible, otherwise return <code>Error</code> object indicating error reason(i.e. \\(T_j\\) becomes negative, \\(j\\) becomes negative, etc.). For derivation, see formulation.The example code for this plot is found example <code>&lt;autoware/trajectory/utils/pretty_build.hpp&gt;</code> <ul><li><code>pretty_build</code></li></ul> A convenient function that will almost surely succeed in constructing a Trajectory class unless the given points size is 0 or 1.Input points are interpolated to 3 points using <code>Linear</code> and to 4 points using <code>Cubic</code> so that it returns<ul><li><code>Cubic</code> interpolated Trajectory class(by default), or</li><li><code>Akima</code> interpolated class if the parameter <code>use_akima = true</code></li></ul>All of the properties are interpolated by <code>default</code> interpolators setting.You may need to call <code>align_orientation_with_trajectory_direction</code> if you did not give desired orientation. View in Drawio"},{"location":"common/autoware_trajectory/#derivation-of-shift","title":"Derivation of <code>shift</code>","text":"<p><code>shift</code> function laterally offsets given curve by \\(l(s)\\) in normal direction at each point following the lateral time-jerk profile as shown bellow.</p> <p></p> <p>Starting from the initial longitudinal velocity of \\(v_{0}^{\\mathrm{lon}}\\) and longitudinal acceleration of \\(a^{\\mathrm{lon}}\\), at each time \\(t_{1}, \\cdots, t_{7}\\), the lateral offset \\(l_{i}\\) at the corresponding longitudinal position \\(s_{i}\\)(with the longitudinal velocity \\(v_{i}\\)) is expressed as follows.</p> \\[ \\begin{align} &amp; t_{1}: &amp; s_{1} &amp;= v^{\\rm lon}_0 T_j + \\frac{1}{2} a^{\\rm lon} T_j^2, &amp; v_{1} &amp;= v^{\\rm lon}_0 + a^{\\rm lon} T_j, &amp; l_{1} &amp;= \\frac{1}{6}jT_j^3 \\\\ &amp; t_{2}: &amp; s_{2} &amp;= v^{\\rm lon}_1 T_a + \\frac{1}{2} a^{\\rm lon} T_a^2, &amp; v_{2} &amp;= v^{\\rm lon}_1 + a^{\\rm lon} T_a, &amp; l_{2} &amp;= \\frac{1}{6}j T_j^3 + \\frac{1}{2} j T_a T_j^2 + \\frac{1}{2} j T_a^2 T_j \\\\ &amp; t_{3}: &amp; s_{3} &amp;= v^{\\rm lon}_2 T_j + \\frac{1}{2} a^{\\rm lon} T_j^2, &amp; v_{3} &amp;= v^{\\rm lon}_2 + a^{\\rm lon} T_j, &amp; l_{3} &amp;= j  T_j^3 + \\frac{3}{2} j T_a T_j^2 + \\frac{1}{2} j T_a^2 T_j \\\\ &amp; t_{4}: &amp; s_{4} &amp;= v^{\\rm lon}_3 T_v + \\frac{1}{2} a^{\\rm lon} T_v^2, &amp; v_{4} &amp;= v^{\\rm lon}_3 + a^{\\rm lon} T_v, &amp; l_{4} &amp;= j T_j^3 + \\frac{3}{2} j T_a T_j^2 + \\frac{1}{2} j T_a^2 T_j + j(T_a + T_j)T_j T_v \\\\ &amp; t_{5}: &amp; s_{5} &amp;= v^{\\rm lon}_4 T_j + \\frac{1}{2} a^{\\rm lon} T_j^2, &amp; v_{5} &amp;= v^{\\rm lon}_4 + a^{\\rm lon} T_j, &amp; l_{5} &amp;= \\frac{11}{6} j T_j^3 + \\frac{5}{2} j T_a T_j^2 + \\frac{1}{2} j T_a^2 T_j + j(T_a + T_j)T_j T_v \\\\ &amp; t_{6}: &amp; s_{6} &amp;= v^{\\rm lon}_5 T_a + \\frac{1}{2} a^{\\rm lon} T_a^2, &amp; v_{6} &amp;= v^{\\rm lon}_5 + a^{\\rm lon} T_a, &amp; l_{6} &amp;= \\frac{11}{6} j T_j^3 + 3 j T_a T_j^2 + j T_a^2 T_j + j(T_a + T_j)T_j T_v \\\\ &amp; t_{7}: &amp; s_{7} &amp;= v^{\\rm lon}_6 T_j + \\frac{1}{2} a^{\\rm lon} T_j^2, &amp; v_{7} &amp;= v^{\\rm lon}_6 + a^{\\rm lon} T_j, &amp; l_{7} &amp;= 2 j T_j^3 + 3 j T_a T_j^2 + j T_a^2 T_j + j(T_a + T_j)T_j T_v \\end{align} \\] <p>Given following inputs,</p> <ul> <li>desired longitudinal distance \\(L_{\\mathrm{lon}}\\)</li> <li>desired lateral shift distance \\(L\\)</li> <li>longitudinal initial velocity \\(v_{\\mathrm{lon}}\\)</li> <li>longitudinal acceleration \\(a_{\\mathrm{lon}}\\)</li> <li>lateral acceleration limit \\(a_{\\mathrm{lim}}^{\\mathrm{lat}}\\)</li> </ul> <p><code>shift</code> internally computes</p> <ul> <li>total time of shift \\(T_{\\mathrm{total}}\\)</li> <li>maximum lateral acceleration \\(a_{\\mathrm{max}}^{\\mathrm{lat}}\\) during the shift</li> <li>constant/zero jerk time \\(T_{\\mathrm{j}}, T_{\\mathrm{a}}\\) respectively</li> <li>required jerk \\(j\\)</li> </ul> <p>as following</p> \\[ \\begin{align} T_{\\mathrm{total}} &amp;= \\text{(time to travel $L_{\\mathrm{lon}}$ from $v_{\\mathrm{lon}}$ under $a_{\\mathrm{lon}}$)} \\\\ a_{\\rm max}^{\\rm lat}  &amp;= \\frac{8L}{T_{\\rm total}^2} \\\\ T_j&amp;=\\frac{T_{\\rm total}}{2} - \\frac{2L}{a_{\\rm lim}^{\\rm lat} T_{\\rm total}}\\\\ T_a&amp;=\\frac{4L}{a_{\\rm lim}^{\\rm lat} T_{\\rm total}} - \\frac{T_{\\rm total}}{2}\\\\ j&amp;=\\frac{2a_{\\rm lim} ^{\\mathrm{lat} 2}T_{\\rm total}}{a_{\\rm lim}^{\\rm lat} T_{\\rm total}^2-4L} \\end{align} \\] <p>to obtain \\((s_{i}, l_{i})\\) respectively. Note that \\(l_{7} == L\\).</p> <p>If \\(a_{\\mathrm{max}}^{\\mathrm{lat}} &gt; a_{\\mathrm{lim}}^{\\mathrm{lat}}\\), then \\(l_{i}\\) is simply</p> \\[ \\begin{align} t &amp;= \\frac{T_{\\mathrm{total}}}{4} \\\\ s_{1} &amp;= v_{\\mathrm{lon}}t + \\frac{1}{2} a_{\\mathrm{lon}}t^2, &amp; l_{1} &amp;= \\frac{L}{12} \\\\ s_{2} &amp;= s_{1} + 2 (v_{0} + a_{\\mathrm{lon}}t)t + 2a_{\\mathrm{lon}}t^2, &amp; l_{2} &amp;= \\frac{11L}{12} \\\\ s_{3} &amp;= L_{\\mathrm{lon}}, &amp; l_{3} &amp;= L \\end{align} \\]"},{"location":"common/autoware_trajectory/#example-usage","title":"Example Usage","text":""},{"location":"common/autoware_trajectory/#pretty_build","title":"<code>pretty_build</code>","text":"<p><code>pretty_build</code> is a convenient wrapper tailored for most Autoware Planning/Control component, which will never fail to interpolate unless the given points size is 0 or 1.</p> ./examples/example_pretty_build.cpp:93:97<pre><code>  auto trajectory_opt = autoware::experimental::trajectory::pretty_build(points);\nif (!trajectory_opt) {\nreturn 1;\n}\nauto &amp; trajectory = trajectory_opt.value();\n</code></pre>"},{"location":"common/autoware_trajectory/#use-custom-interpolator","title":"use custom Interpolator","text":"<p>You can also specify interpolation method to <code>Builder{}</code> before calling <code>.build(points)</code></p> <pre><code>using autoware::experimental::trajectory::interpolator::CubicSpline;\n\nstd::optional&lt;Trajectory&lt;autoware_planning_msgs::msg::PathPoint&gt;&gt; trajectory =\nTrajectory&lt;autoware_planning_msgs::msg::PathPoint&gt;::Builder{}\n.set_xy_interpolator&lt;CubicSpline&gt;()  // Set interpolator for x-y plane\n.build(points);\n</code></pre>"},{"location":"common/autoware_trajectory/#cropshorten-trajectory","title":"crop/shorten Trajectory","text":"<pre><code>trajectory-&gt;crop(1.0, 2.0);\n</code></pre>"},{"location":"common/autoware_trajectory/#shift-trajectory","title":"<code>shift</code> Trajectory","text":"./examples/example_shift.cpp:97:117<pre><code>  // six points\nconst double longitudinal_velocity = 2.77;\nconst double lateral_jerk = 1.0;\nconst double lateral_shift = 2.5;\nconst double lateral_acc_limit = 5.0;\nconst double longitudinal_dist = autoware::motion_utils::calc_longitudinal_dist_from_jerk(\nlateral_shift, lateral_jerk, longitudinal_velocity);\n\nconst auto start_s = 3.0;\nconst ShiftInterval shift_interval{start_s, start_s + longitudinal_dist, lateral_shift};\nconst ShiftParameters shift_parameter{\nlongitudinal_velocity,\nlateral_acc_limit,\n};\n\nauto shifted_trajectory_info =\nautoware::experimental::trajectory::shift(*trajectory, shift_interval, shift_parameter);\nif (!shifted_trajectory_info) {\nstd::cout &lt;&lt; shifted_trajectory_info.error().what &lt;&lt; std::endl;\nreturn 1;\n}\n</code></pre> <p>View in Drawio</p>"},{"location":"common/autoware_trajectory/#insert-and-set-velocity-profile","title":"Insert and set velocity profile","text":"<p>Set 3.0[m] ~ 5.0[m] part of velocity to 0.0</p> <pre><code>trajectory-&gt;longitudinal_velocity_mps(3.0, 5.0) = 0.0;\n</code></pre>"},{"location":"common/autoware_trajectory/#restore-points","title":"Restore points","text":"<pre><code>std::vector&lt;autoware_planning_msgs::msg::PathPoint&gt; points = trajectory-&gt;restore();\n</code></pre>"},{"location":"common/autoware_vehicle_info_utils/","title":"Vehicle Info Util","text":""},{"location":"common/autoware_vehicle_info_utils/#vehicle-info-util","title":"Vehicle Info Util","text":""},{"location":"common/autoware_vehicle_info_utils/#purpose","title":"Purpose","text":"<p>This package is to get vehicle info parameters.</p>"},{"location":"common/autoware_vehicle_info_utils/#description","title":"Description","text":"<p>In here, you can check the vehicle dimensions with more detail. The current format supports only the Ackermann model. This file defines the model assumed in autoware path planning, control, etc. and does not represent the exact physical model. If a model other than the Ackermann model is used, it is assumed that a vehicle interface will be designed to change the control output for the model.</p>"},{"location":"common/autoware_vehicle_info_utils/#versioning-policy","title":"Versioning Policy","text":"<p>We have implemented a versioning system for the <code>vehicle_info.param.yaml</code> file to ensure clarity and consistency in file format across different versions of Autoware and its external applications. Please see discussion for the details.</p>"},{"location":"common/autoware_vehicle_info_utils/#how-to-operate","title":"How to Operate","text":"<ul> <li>The current file format is set as an unversioned base version (<code>version:</code> field is commented out).</li> <li>For the next update involving changes (such as additions, deletions, or modifications):<ul> <li>Uncomment and update the version line at the beginning of the file.</li> <li>Initiate versioning by assigning a version number, starting from <code>0.1.0</code>. Follow the semantic versioning format (MAJOR.MINOR.PATCH).</li> <li>Update this Readme.md too.</li> </ul> </li> <li>For subsequent updates, continue incrementing the version number in accordance with the changes made.<ul> <li>Discuss how to increment version depending on the amount of changes made to the file.</li> </ul> </li> </ul> <pre><code>/**:\nros__parameters:\n# version: 0.1.0 # Uncomment and update this line for future format changes.\nwheel_radius: 0.383\n...\n</code></pre>"},{"location":"common/autoware_vehicle_info_utils/#why-versioning","title":"Why Versioning?","text":"<ul> <li>Consistency Across Updates: Implementing version control will allow accurate tracking of changes over time and changes in vehicle information parameters.</li> <li>Clarity for External Applications: External applications that depend on <code>vehicle_info.param.yaml</code> need to reference the correct file version for optimal compatibility and functionality.</li> <li>Simplified Management for Customized Branches: Assigning versions directly to the <code>vehicle_info.param.yaml</code> file simplifies management compared to maintaining separate versions for multiple customized Autoware branches. This approach streamlines version tracking and reduces complexity.</li> </ul>"},{"location":"common/autoware_vehicle_info_utils/#scripts","title":"Scripts","text":""},{"location":"common/autoware_vehicle_info_utils/#minimum-turning-radius","title":"Minimum turning radius","text":"<pre><code>$ ros2 run autoware_vehicle_info_utils min_turning_radius_calculator.py\nyaml path is /home/autoware/pilot-auto/install/autoware_vehicle_info_utils/share/autoware_vehicle_info_utils/config/vehicle_info.param.yaml\nMinimum turning radius is 3.253042620027102 [m] for rear, 4.253220695862465 [m] for front.\n</code></pre> <p>You can designate yaml file with <code>-y</code> option as follows.</p> <pre><code>ros2 run autoware_vehicle_info_utils min_turning_radius_calculator.py -y &lt;path-to-yaml&gt;\n</code></pre>"},{"location":"common/autoware_vehicle_info_utils/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p>TBD.</p>"},{"location":"control/autoware_core_control/","title":"Autoware Core Control","text":""},{"location":"control/autoware_core_control/#autoware-core-control","title":"Autoware Core Control","text":""},{"location":"control/autoware_core_control/#overview","title":"Overview","text":"<p>The <code>autoware_core_control</code> is a meta-package within the Autoware project, designed to manage and organize various control-related modules essential for autonomous vehicle operations. This package serves as a central point for integrating different control functionalities, such as trajectory following.</p>"},{"location":"control/autoware_core_control/#usage","title":"Usage","text":"<p>The <code>autoware_core_control</code> meta-package is used to launch and manage control modules as part of the Autoware system. You can start the system using:</p> <pre><code>ros2 launch autoware_launch control_launch.xml\n</code></pre>"},{"location":"control/autoware_simple_pure_pursuit/","title":"Simple Pure Pursuit","text":""},{"location":"control/autoware_simple_pure_pursuit/#macro-rendering-error","title":"Macro Rendering Error","text":"<p>File: <code>control/autoware_simple_pure_pursuit/README.md</code></p> <p>KeyError: 'default'</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/mkdocs_macros/plugin.py\", line 688, in render\n    return md_template.render(**page_variables)\n  File \"/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 24, in top-level template code\n  File \"/home/runner/work/autoware_core/autoware_core/mkdocs_macros.py\", line 73, in json_to_markdown\n    return format_json(data)\n  File \"/home/runner/work/autoware_core/autoware_core/mkdocs_macros.py\", line 64, in format_json\n    markdown_table = tabulate(extract_parameter_info(parameters), headers=\"keys\", tablefmt=\"github\")\n  File \"/home/runner/work/autoware_core/autoware_core/mkdocs_macros.py\", line 53, in extract_parameter_info\n    param[\"Default\"] = v[\"default\"]\nKeyError: 'default'\n</code></pre>"},{"location":"localization/autoware_core_localization/","title":"Autoware Core Localization","text":""},{"location":"localization/autoware_core_localization/#autoware-core-localization","title":"Autoware Core Localization","text":""},{"location":"localization/autoware_core_localization/#overview","title":"Overview","text":"<p>The <code>autoware_core_localization</code> is a meta-package within the Autoware project, designed to manage and organize various localization-related modules essential for autonomous vehicle operations. This package serves as a central point for integrating different localization functionalities to estimate the vehicle's pose, velocity, and acceleration within an environment.</p>"},{"location":"localization/autoware_core_localization/#usage","title":"Usage","text":"<p>The <code>autoware_core_localization</code> meta-package is used to launch and manage localization modules as part of the Autoware system. You can start the system using:</p> <pre><code>ros2 launch autoware_launch localization_launch.xml\n</code></pre>"},{"location":"localization/autoware_ekf_localizer/","title":"Overview","text":""},{"location":"localization/autoware_ekf_localizer/#overview","title":"Overview","text":"<p>The Extend Kalman Filter Localizer estimates robust and less noisy robot pose and twist by integrating the 2D vehicle dynamics model with input ego-pose and ego-twist messages. The algorithm is designed especially for fast-moving robots such as autonomous driving systems.</p>"},{"location":"localization/autoware_ekf_localizer/#flowchart","title":"Flowchart","text":"<p>The overall flowchart of the autoware_ekf_localizer is described below.</p> <p> </p>"},{"location":"localization/autoware_ekf_localizer/#features","title":"Features","text":"<p>This package includes the following features:</p> <ul> <li>Time delay compensation for input messages, which enables proper integration of input information with varying time delays. This is important especially for high-speed moving robots, such as autonomous driving vehicles. (see the following figure).</li> <li>Automatic estimation of yaw bias prevents modeling errors caused by sensor mounting angle errors, which can improve estimation accuracy.</li> <li>Mahalanobis distance gate enables probabilistic outlier detection to determine which inputs should be used or ignored.</li> <li>Smooth update, the Kalman Filter measurement update is typically performed when a measurement is obtained, but it can cause large changes in the estimated value, especially for low-frequency measurements. Since the algorithm can consider the measurement time, the measurement data can be divided into multiple pieces and integrated smoothly while maintaining consistency (see the following figure).</li> <li>Calculation of vertical correction amount from pitch mitigates localization instability on slopes. For example, when going uphill, it behaves as if it is buried in the ground (see the left side of the \"Calculate delta from pitch\" figure) because EKF only considers 3DoF(x,y,yaw). Therefore, EKF corrects the z-coordinate according to the formula (see the right side of the \"Calculate delta from pitch\" figure).</li> </ul> <p> </p> <p> </p> <p> </p>"},{"location":"localization/autoware_ekf_localizer/#node","title":"Node","text":""},{"location":"localization/autoware_ekf_localizer/#subscribed-topics","title":"Subscribed Topics","text":"Name Type Description <code>measured_pose_with_covariance</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> Input pose source with the measurement covariance matrix. <code>measured_twist_with_covariance</code> <code>geometry_msgs::msg::TwistWithCovarianceStamped</code> Input twist source with the measurement covariance matrix. <code>initialpose</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> Initial pose for EKF. The estimated pose is initialized with zeros at the start. It is initialized with this message whenever published."},{"location":"localization/autoware_ekf_localizer/#published-topics","title":"Published Topics","text":"Name Type Description <code>ekf_odom</code> <code>nav_msgs::msg::Odometry</code> Estimated odometry. <code>ekf_pose</code> <code>geometry_msgs::msg::PoseStamped</code> Estimated pose. <code>ekf_pose_with_covariance</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> Estimated pose with covariance. <code>ekf_biased_pose</code> <code>geometry_msgs::msg::PoseStamped</code> Estimated pose including the yaw bias <code>ekf_biased_pose_with_covariance</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> Estimated pose with covariance including the yaw bias <code>ekf_twist</code> <code>geometry_msgs::msg::TwistStamped</code> Estimated twist. <code>ekf_twist_with_covariance</code> <code>geometry_msgs::msg::TwistWithCovarianceStamped</code> The estimated twist with covariance. <code>diagnostics</code> <code>diagnostics_msgs::msg::DiagnosticArray</code> The diagnostic information. <code>debug/processing_time_ms</code> <code>autoware_internal_debug_msgs::msg::Float64Stamped</code> The processing time [ms]."},{"location":"localization/autoware_ekf_localizer/#published-tf","title":"Published TF","text":"<ul> <li>base_link   TF from <code>map</code> coordinate to estimated pose.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#functions","title":"Functions","text":""},{"location":"localization/autoware_ekf_localizer/#predict","title":"Predict","text":"<p>The current robot state is predicted from previously estimated data using a given prediction model. This calculation is called at a constant interval (<code>predict_frequency [Hz]</code>). The prediction equation is described at the end of this page.</p>"},{"location":"localization/autoware_ekf_localizer/#measurement-update","title":"Measurement Update","text":"<p>Before the update, the Mahalanobis distance is calculated between the measured input and the predicted state, the measurement update is not performed for inputs where the Mahalanobis distance exceeds the given threshold.</p> <p>The predicted state is updated with the latest measured inputs, measured_pose, and measured_twist. The updates are performed with the same frequency as prediction, usually at a high frequency, in order to enable smooth state estimation.</p>"},{"location":"localization/autoware_ekf_localizer/#parameter-description","title":"Parameter description","text":"<p>The parameters are set in <code>launch/ekf_localizer.launch</code> .</p>"},{"location":"localization/autoware_ekf_localizer/#for-node","title":"For Node","text":"Name Type Description Default Range show_debug_info boolean Flag to display debug info 0 N/A predict_frequency float Frequency for filtering and publishing [Hz] 50 N/A tf_rate float Frequency for tf broadcasting [Hz] 50 N/A extend_state_step integer Max delay step which can be dealt with in EKF. Large number increases computational cost. 50 N/A enable_yaw_bias_estimation boolean Flag to enable yaw bias estimation 1 N/A"},{"location":"localization/autoware_ekf_localizer/#for-pose-measurement","title":"For pose measurement","text":"Name Type Description Default Range pose_additional_delay float Additional delay time for pose measurement [s] 0 N/A pose_measure_uncertainty_time float Measured time uncertainty used for covariance calculation [s] 0.01 N/A pose_smoothing_steps integer A value for smoothing steps 5 N/A pose_gate_dist float Limit of Mahalanobis distance used for outliers detection 49.5 N/A"},{"location":"localization/autoware_ekf_localizer/#for-twist-measurement","title":"For twist measurement","text":"Name Type Description Default Range twist_additional_delay float Additional delay time for twist [s] 0 N/A twist_smoothing_steps integer A value for smoothing steps 2 N/A twist_gate_dist float Limit of Mahalanobis distance used for outliers detection 46.1 N/A"},{"location":"localization/autoware_ekf_localizer/#for-process-noise","title":"For process noise","text":"Name Type Description Default Range proc_stddev_vx_c float Standard deviation of process noise in time differentiation expression of linear velocity x, noise for d_vx = 0 10 N/A proc_stddev_wz_c float Standard deviation of process noise in time differentiation expression of angular velocity z, noise for d_wz = 0 5 N/A proc_stddev_yaw_c float Standard deviation of process noise in time differentiation expression of yaw, noise for d_yaw = omega 0.005 N/A <p>note: process noise for positions x &amp; y are calculated automatically from nonlinear dynamics.</p>"},{"location":"localization/autoware_ekf_localizer/#simple-1d-filter-parameters","title":"Simple 1D Filter Parameters","text":"Name Type Description Default Range z_filter_proc_dev float Simple1DFilter - Z filter process deviation 1 N/A roll_filter_proc_dev float Simple1DFilter - Roll filter process deviation 0.1 N/A pitch_filter_proc_dev float Simple1DFilter - Pitch filter process deviation 0.1 N/A"},{"location":"localization/autoware_ekf_localizer/#for-diagnostics","title":"For diagnostics","text":"Name Type Description Default Range pose_no_update_count_threshold_warn integer The threshold at which a WARN state is triggered due to the Pose Topic update not happening continuously for a certain number of times 50 N/A pose_no_update_count_threshold_error integer The threshold at which an ERROR state is triggered due to the Pose Topic update not happening continuously for a certain number of times 100 N/A twist_no_update_count_threshold_warn integer The threshold at which a WARN state is triggered due to the Twist Topic update not happening continuously for a certain number of times 50 N/A twist_no_update_count_threshold_error integer The threshold at which an ERROR state is triggered due to the Twist Topic update not happening continuously for a certain number of times 100 N/A ellipse_scale float The scale factor to apply the error ellipse size 3 N/A error_ellipse_size float The long axis size of the error ellipse to trigger a ERROR state 1.5 N/A warn_ellipse_size float The long axis size of the error ellipse to trigger a WARN state 1.2 N/A error_ellipse_size_lateral_direction float The lateral direction size of the error ellipse to trigger a ERROR state 0.3 N/A warn_ellipse_size_lateral_direction float The lateral direction size of the error ellipse to trigger a WARN state 0.25 N/A"},{"location":"localization/autoware_ekf_localizer/#misc","title":"Misc","text":"Name Type Description Default Range threshold_observable_velocity_mps float Minimum value for velocity that will be used for EKF. Mainly used for dead zone in velocity sensor [m/s] (0.0 means disabled) 0.0 N/A pose_frame_id string Parent frame_id of EKF output pose map N/A"},{"location":"localization/autoware_ekf_localizer/#how-to-tune-ekf-parameters","title":"How to tune EKF parameters","text":""},{"location":"localization/autoware_ekf_localizer/#0-preliminaries","title":"0. Preliminaries","text":"<ul> <li>Check header time in pose and twist message is set to sensor time appropriately, because time delay is calculated from this value. If it is difficult to set an appropriate time due to the timer synchronization problem, use <code>twist_additional_delay</code> and <code>pose_additional_delay</code> to correct the time.</li> <li>Check if the relation between measurement pose and twist is appropriate (whether the derivative of the pose has a similar value to twist). This discrepancy is caused mainly by unit error (such as confusing radian/degree) or bias noise, and it causes large estimation errors.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#1-tune-sensor-parameters","title":"1. Tune sensor parameters","text":"<p>Set standard deviation for each sensor. The <code>pose_measure_uncertainty_time</code> is for the uncertainty of the header timestamp data. You can also tune a number of steps for smoothing for each observed sensor data by tuning <code>*_smoothing_steps</code>. Increasing the number will improve the smoothness of the estimation, but may have an adverse effect on the estimation performance.</p> <ul> <li><code>pose_measure_uncertainty_time</code></li> <li><code>pose_smoothing_steps</code></li> <li><code>twist_smoothing_steps</code></li> </ul>"},{"location":"localization/autoware_ekf_localizer/#2-tune-process-model-parameters","title":"2. Tune process model parameters","text":"<ul> <li><code>proc_stddev_vx_c</code> : set to maximum linear acceleration</li> <li><code>proc_stddev_wz_c</code> : set to maximum angular acceleration</li> <li><code>proc_stddev_yaw_c</code> : This parameter describes the correlation between the yaw and yaw rate. A large value means the change in yaw does not correlate to the estimated yaw rate. If this is set to 0, it means the change in estimated yaw is equal to yaw rate. Usually, this should be set to 0.</li> <li><code>proc_stddev_yaw_bias_c</code> : This parameter is the standard deviation for the rate of change in yaw bias. In most cases, yaw bias is constant, so it can be very small, but must be non-zero.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#3-tune-gate-parameters","title":"3. Tune gate parameters","text":"<p>EKF performs gating using Mahalanobis distance before updating by observation. The gate size is determined by the <code>pose_gate_dist</code> parameter and the <code>twist_gate_dist</code>. If the Mahalanobis distance is larger than this value, the observation is ignored.</p> <p>This gating process is based on a statistical test using the chi-square distribution. As modeled, we assume that the Mahalanobis distance follows a chi-square distribution with 3 degrees of freedom for pose and 2 degrees of freedom for twist.</p> <p>Currently, the accuracy of covariance estimation itself is not very good, so it is recommended to set the significance level to a very small value to reduce rejection due to false positives.</p> Significance level Threshold for 2 dof Threshold for 3 dof \\(10 ^ {-2}\\) 9.21 11.3 \\(10 ^ {-3}\\) 13.8 16.3 \\(10 ^ {-4}\\) 18.4 21.1 \\(10 ^ {-5}\\) 23.0 25.9 \\(10 ^ {-6}\\) 27.6 30.7 \\(10 ^ {-7}\\) 32.2 35.4 \\(10 ^ {-8}\\) 36.8 40.1 \\(10 ^ {-9}\\) 41.4 44.8 \\(10 ^ {-10}\\) 46.1 49.5"},{"location":"localization/autoware_ekf_localizer/#kalman-filter-model","title":"Kalman Filter Model","text":""},{"location":"localization/autoware_ekf_localizer/#kinematics-model-in-update-function","title":"kinematics model in update function","text":"<p>where, \\(\\theta_k\\) represents the vehicle's heading angle, including the mounting angle bias. \\(b_k\\) is a correction term for the yaw bias, and it is modeled so that \\((\\theta_k+b_k)\\) becomes the heading angle of the base_link. The pose_estimator is expected to publish the base_link in the map coordinate system. However, the yaw angle may be offset due to calibration errors. This model compensates this error and improves estimation accuracy.</p>"},{"location":"localization/autoware_ekf_localizer/#time-delay-model","title":"time delay model","text":"<p>The measurement time delay is handled by an augmented state [1] (See, Section 7.3 FIXED-LAG SMOOTHING).</p> <p></p> <p>Note that, although the dimension gets larger since the analytical expansion can be applied based on the specific structures of the augmented states, the computational complexity does not significantly change.</p>"},{"location":"localization/autoware_ekf_localizer/#test-result-with-autoware-ndt","title":"Test Result with Autoware NDT","text":""},{"location":"localization/autoware_ekf_localizer/#diagnostics","title":"Diagnostics","text":""},{"location":"localization/autoware_ekf_localizer/#the-conditions-that-result-in-a-warn-state","title":"The conditions that result in a WARN state","text":"<ul> <li>The node is not in the activate state.</li> <li>The initial pose is not set.</li> <li>The number of consecutive no measurement update via the Pose/Twist topic exceeds the <code>pose_no_update_count_threshold_warn</code>/<code>twist_no_update_count_threshold_warn</code>.</li> <li>The timestamp of the Pose/Twist topic is beyond the delay compensation range.</li> <li>The Pose/Twist topic is beyond the range of Mahalanobis distance for covariance estimation.</li> <li>The covariance ellipse is bigger than threshold <code>warn_ellipse_size</code> for long axis or <code>warn_ellipse_size_lateral_direction</code> for lateral_direction.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#the-conditions-that-result-in-an-error-state","title":"The conditions that result in an ERROR state","text":"<ul> <li>The number of consecutive no measurement update via the Pose/Twist topic exceeds the <code>pose_no_update_count_threshold_error</code>/<code>twist_no_update_count_threshold_error</code>.</li> <li>The covariance ellipse is bigger than threshold <code>error_ellipse_size</code> for long axis or <code>error_ellipse_size_lateral_direction</code> for lateral_direction.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#known-issues","title":"Known issues","text":"<ul> <li>If multiple pose_estimators are used, the input to the EKF will include multiple yaw biases corresponding to each source. However, the current EKF assumes the existence of only one yaw bias. Therefore, yaw bias <code>b_k</code> in the current EKF state would not make any sense and cannot correctly handle these multiple yaw biases. Thus, future work includes introducing yaw bias for each sensor with yaw estimation.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#reference","title":"reference","text":"<p>[1] Anderson, B. D. O., &amp; Moore, J. B. (1979). Optimal filtering. Englewood Cliffs, NJ: Prentice-Hall.</p>"},{"location":"localization/autoware_localization_util/","title":"autoware_localization_util","text":""},{"location":"localization/autoware_localization_util/#autoware_localization_util","title":"autoware_localization_util","text":""},{"location":"localization/autoware_localization_util/#overview","title":"Overview","text":"<p><code>autoware_localization_util</code> is a collection of localization utility packages. It contains 5 individual library that used by autoware localization nodes.</p> <ul> <li><code>covariance_ellipse</code> 2d covariance visualization wrapper.</li> <li><code>smart_pose_buffer</code> pose buffer management library which contains interpolate and data validation.</li> <li><code>tree_structured_parzen_estimator</code> A Tree Structured Parzen Estimator library.</li> <li><code>util_func</code> A tool library which contains several function for localization nodes.</li> </ul>"},{"location":"localization/autoware_localization_util/#design","title":"Design","text":"<ul> <li><code>covariance_ellipse</code> Translate <code>geometry_msgs::msg::PoseWithCovariance</code> message into ellipse visual marker to demonstrate covariance distribution.</li> <li><code>smart_pose_buffer</code> A buffer library which implements pose message buffering, pose interpolate and pose validation.</li> <li><code>tree_structured_parzen_estimator</code> A Probability Estimator library that includes estimator and log likelihood ratio calculation.</li> <li><code>util_func</code> Tool function collection.</li> </ul>"},{"location":"localization/autoware_localization_util/#usage","title":"Usage","text":""},{"location":"localization/autoware_localization_util/#covariance_ellipse","title":"covariance_ellipse","text":"<p>Include header file to use:</p> <pre><code>#include \"autoware/localization_util/covariance_ellipse.hpp\"\n</code></pre> <p>calculate ellipse and visualize</p> <pre><code>autoware::localization_util::Ellipse ellipse_ = autoware::localization_util::calculate_xy_ellipse(input_msg-&gt;pose, scale_);\n\nconst auto ellipse_marker = autoware::localization_util::create_ellipse_marker(\nellipse_, input_msg-&gt;header, input_msg-&gt;pose);\n</code></pre>"},{"location":"localization/autoware_localization_util/#smart_pose_buffer","title":"smart_pose_buffer","text":"<p>buffer init</p> <pre><code>#include \"autoware/localization_util/smart_pose_buffer.hpp\"\n\nusing autoware::localization_util::SmartPoseBuffer;\n\nstd::unique_ptr&lt;autoware::localization_util::SmartPoseBuffer&gt; initial_pose_buffer_;\ninitial_pose_buffer_ = std::make_unique&lt;SmartPoseBuffer&gt;(\nthis-&gt;get_logger(), param_.validation.initial_pose_timeout_sec,\nparam_.validation.initial_pose_distance_tolerance_m);\n</code></pre> <p>interpolate and pop out old pose message</p> <pre><code>std::optional&lt;SmartPoseBuffer::InterpolateResult&gt; interpolation_result_opt =\ninitial_pose_buffer_-&gt;interpolate(sensor_ros_time);\n\n...\n\ninitial_pose_buffer_-&gt;pop_old(sensor_ros_time);\nconst SmartPoseBuffer::InterpolateResult &amp; interpolation_result =\ninterpolation_result_opt.value();\n</code></pre> <p>clear buffer</p> <pre><code>initial_pose_buffer_-&gt;clear();\n</code></pre>"},{"location":"localization/autoware_localization_util/#tree_structured_parzen_estimator","title":"tree_structured_parzen_estimator","text":"<p>init the estimator. n_startup_trials -- The number of initial random trials in the TPE (Tree-Structured Parzen Estimator). This value should be equal to or less than 'initial_estimate_particles_num' and more than 0. If it is equal to 'initial_estimate_particles_num', the search will be the same as a full random search.</p> <pre><code>#include \"autoware/localization_util/tree_structured_parzen_estimator.hpp\"\n\nusing autoware::localization_util::TreeStructuredParzenEstimator;\n\nTreeStructuredParzenEstimator tpe(\nTreeStructuredParzenEstimator::Direction::MAXIMIZE,\nparam_.initial_pose_estimation.n_startup_trials, sample_mean, sample_stddev);\n</code></pre> <p>get estimation result</p> <pre><code>const TreeStructuredParzenEstimator::Input input = tpe.get_next_input();\n</code></pre> <p>add new data to the estimator</p> <pre><code>TreeStructuredParzenEstimator::Input result(6);\nresult[0] = pose.position.x;\nresult[1] = pose.position.y;\nresult[2] = pose.position.z;\nresult[3] = rpy.x;\nresult[4] = rpy.y;\nresult[5] = rpy.z;\ntpe.add_trial(TreeStructuredParzenEstimator::Trial{result, ndt_result.transform_probability});\n</code></pre>"},{"location":"localization/autoware_localization_util/#util_func","title":"util_func","text":"<p>include header file to use</p> <pre><code>#include \"autoware/localization_util/util_func.hpp\"\n\nusing autoware::localization_util::exchange_color_crc;\nusing autoware::localization_util::matrix4f_to_pose;\nusing autoware::localization_util::point_to_vector3d;\nusing autoware::localization_util::pose_to_matrix4f;\n</code></pre> <p>list of useful function</p> <pre><code>std_msgs::msg::ColorRGBA exchange_color_crc(double x);\ndouble calc_diff_for_radian(const double lhs_rad, const double rhs_rad);\ngeometry_msgs::msg::Vector3 get_rpy(const geometry_msgs::msg::Pose &amp; pose);\ngeometry_msgs::msg::Vector3 get_rpy(const geometry_msgs::msg::PoseStamped &amp; pose);\ngeometry_msgs::msg::Vector3 get_rpy(const geometry_msgs::msg::PoseWithCovarianceStamped &amp; pose);\ngeometry_msgs::msg::Quaternion rpy_rad_to_quaternion(\nconst double r_rad, const double p_rad, const double y_rad);\ngeometry_msgs::msg::Quaternion rpy_deg_to_quaternion(\nconst double r_deg, const double p_deg, const double y_deg);\ngeometry_msgs::msg::Twist calc_twist(\nconst geometry_msgs::msg::PoseStamped &amp; pose_a, const geometry_msgs::msg::PoseStamped &amp; pose_b);\ngeometry_msgs::msg::PoseStamped interpolate_pose(\nconst geometry_msgs::msg::PoseStamped &amp; pose_a, const geometry_msgs::msg::PoseStamped &amp; pose_b,\nconst rclcpp::Time &amp; time_stamp);\ngeometry_msgs::msg::PoseStamped interpolate_pose(\nconst geometry_msgs::msg::PoseWithCovarianceStamped &amp; pose_a,\nconst geometry_msgs::msg::PoseWithCovarianceStamped &amp; pose_b, const rclcpp::Time &amp; time_stamp);\nEigen::Affine3d pose_to_affine3d(const geometry_msgs::msg::Pose &amp; ros_pose);\nEigen::Matrix4f pose_to_matrix4f(const geometry_msgs::msg::Pose &amp; ros_pose);\ngeometry_msgs::msg::Pose matrix4f_to_pose(const Eigen::Matrix4f &amp; eigen_pose_matrix);\nEigen::Vector3d point_to_vector3d(const geometry_msgs::msg::Point &amp; ros_pos);\ntemplate &lt;class T&gt;\nT transform(const T &amp; input, const geometry_msgs::msg::TransformStamped &amp; transform);double norm(const geometry_msgs::msg::Point &amp; p1, const geometry_msgs::msg::Point &amp; p2);\n\nvoid output_pose_with_cov_to_log(\nconst rclcpp::Logger &amp; logger, const std::string &amp; prefix,\nconst geometry_msgs::msg::PoseWithCovarianceStamped &amp; pose_with_cov);\n</code></pre>"},{"location":"localization/autoware_stop_filter/","title":"stop_filter","text":""},{"location":"localization/autoware_stop_filter/#stop_filter","title":"stop_filter","text":""},{"location":"localization/autoware_stop_filter/#purpose","title":"Purpose","text":"<p>When this function did not exist, each node used a different criterion to determine whether the vehicle is stopping or not, resulting that some nodes were in operation of stopping the vehicle and some nodes continued running in the drive mode. This node aims to:</p> <ul> <li>apply a uniform stopping decision criterion to several nodes.</li> <li>suppress the control noise by overwriting the velocity and angular velocity with zero.</li> </ul>"},{"location":"localization/autoware_stop_filter/#inputs-outputs","title":"Inputs / Outputs","text":""},{"location":"localization/autoware_stop_filter/#input","title":"Input","text":"Name Type Description <code>input/odom</code> <code>nav_msgs::msg::Odometry</code> localization odometry"},{"location":"localization/autoware_stop_filter/#output","title":"Output","text":"Name Type Description <code>output/odom</code> <code>nav_msgs::msg::Odometry</code> odometry with suppressed longitudinal and yaw twist <code>debug/stop_flag</code> <code>autoware_internal_debug_msgs::msg::BoolStamped</code> flag to represent whether the vehicle is stopping or not"},{"location":"localization/autoware_stop_filter/#parameters","title":"Parameters","text":"Name Type Description Default Range vx_threshold float Longitudinal velocity threshold to determine if the vehicle is stopping. [m/s] 0.01 \u22650.0 wz_threshold float Yaw velocity threshold to determine if the vehicle is stopping. [rad/s] 0.01 \u22650.0"},{"location":"localization/autoware_twist2accel/","title":"autoware_twist2accel","text":""},{"location":"localization/autoware_twist2accel/#autoware_twist2accel","title":"autoware_twist2accel","text":""},{"location":"localization/autoware_twist2accel/#purpose","title":"Purpose","text":"<p>This package is responsible for estimating acceleration using the output of <code>ekf_localizer</code>. It uses lowpass filter to mitigate the noise.</p>"},{"location":"localization/autoware_twist2accel/#inputs-outputs","title":"Inputs / Outputs","text":""},{"location":"localization/autoware_twist2accel/#input","title":"Input","text":"Name Type Description <code>input/odom</code> <code>nav_msgs::msg::Odometry</code> localization odometry <code>input/twist</code> <code>geometry_msgs::msg::TwistWithCovarianceStamped</code> twist"},{"location":"localization/autoware_twist2accel/#output","title":"Output","text":"Name Type Description <code>output/accel</code> <code>geometry_msgs::msg::AccelWithCovarianceStamped</code> estimated acceleration"},{"location":"localization/autoware_twist2accel/#parameters","title":"Parameters","text":"Name Type Description Default Range use_odom boolean use odometry if true, else use twist input. 1 N/A accel_lowpass_gain float lowpass gain for lowpass filter in estimating acceleration. 0.9 \u22650.0"},{"location":"localization/autoware_twist2accel/#future-work","title":"Future work","text":"<p>Future work includes integrating acceleration into the EKF state.</p>"},{"location":"map/autoware_core_map/","title":"Autoware Core Map","text":""},{"location":"map/autoware_core_map/#autoware-core-map","title":"Autoware Core Map","text":""},{"location":"map/autoware_core_map/#overview","title":"Overview","text":"<p>The <code>autoware_core_map</code> is a meta-package within the Autoware project, designed to manage and organize various map-related modules essential for autonomous vehicle operations. This package serves as a central point for integrating different map functionalities, such as map loading, serving, visualization, and manipulation.</p>"},{"location":"map/autoware_core_map/#usage","title":"Usage","text":"<p>The <code>autoware_core_map</code> meta-package is used to launch and manage map modules as part of the Autoware system. You can start the system using:</p> <pre><code>ros2 launch autoware_launch map_launch.xml\n</code></pre>"},{"location":"map/autoware_map_loader/","title":"autoware_map_loader package","text":""},{"location":"map/autoware_map_loader/#autoware_map_loader-package","title":"autoware_map_loader package","text":"<p>This package provides the features of loading various maps.</p>"},{"location":"map/autoware_map_loader/#pointcloud_map_loader","title":"pointcloud_map_loader","text":""},{"location":"map/autoware_map_loader/#feature","title":"Feature","text":"<p><code>pointcloud_map_loader</code> provides pointcloud maps to the other Autoware nodes in various configurations. Currently, it supports the following two types:</p> <ul> <li>Publish raw pointcloud map</li> <li>Publish downsampled pointcloud map</li> <li>Send partial pointcloud map loading via ROS 2 service</li> <li>Send differential pointcloud map loading via ROS 2 service</li> </ul> <p>NOTE: We strongly recommend to use divided maps when using large pointcloud map to enable the latter two features (partial and differential load). Please go through the prerequisites section for more details, and follow the instruction for dividing the map and preparing the metadata.</p>"},{"location":"map/autoware_map_loader/#prerequisites","title":"Prerequisites","text":""},{"location":"map/autoware_map_loader/#prerequisites-on-pointcloud-map-files","title":"Prerequisites on pointcloud map file(s)","text":"<p>You may provide either a single .pcd file or multiple .pcd files. If you are using multiple PCD data, it MUST obey the following rules:</p> <ol> <li>The pointcloud map should be projected on the same coordinate defined in <code>map_projection_loader</code>, in order to be consistent with the lanelet2 map and other packages that converts between local and geodetic coordinates. For more information, please refer to the readme of <code>map_projection_loader</code>.</li> <li>It must be divided by straight lines parallel to the x-axis and y-axis. The system does not support division by diagonal lines or curved lines.</li> <li>The division size along each axis should be equal.</li> <li>The division size should be about 20m x 20m. Particularly, care should be taken as using too large division size (for example, more than 100m) may have adverse effects on dynamic map loading features in ndt_scan_matcher and autoware_compare_map_segmentation.</li> <li>All the split maps should not overlap with each other.</li> <li>Metadata file should also be provided. The metadata structure description is provided below.</li> </ol>"},{"location":"map/autoware_map_loader/#metadata-structure","title":"Metadata structure","text":"<p>The metadata should look like this:</p> <pre><code>x_resolution: 20.0\ny_resolution: 20.0\nA.pcd: [1200, 2500] # -&gt; 1200 &lt; x &lt; 1220, 2500 &lt; y &lt; 2520\nB.pcd: [1220, 2500] # -&gt; 1220 &lt; x &lt; 1240, 2500 &lt; y &lt; 2520\nC.pcd: [1200, 2520] # -&gt; 1200 &lt; x &lt; 1220, 2520 &lt; y &lt; 2540\nD.pcd: [1240, 2520] # -&gt; 1240 &lt; x &lt; 1260, 2520 &lt; y &lt; 2540\n</code></pre> <p>where,</p> <ul> <li><code>x_resolution</code> and <code>y_resolution</code></li> <li><code>A.pcd</code>, <code>B.pcd</code>, etc, are the names of PCD files.</li> <li>List such as <code>[1200, 2500]</code> are the values indicate that for this PCD file, x coordinates are between 1200 and 1220 (<code>x_resolution</code> + <code>x_coordinate</code>) and y coordinates are between 2500 and 2520 (<code>y_resolution</code> + <code>y_coordinate</code>).</li> </ul> <p>You may use pointcloud_divider for dividing pointcloud map as well as generating the compatible metadata.yaml.</p>"},{"location":"map/autoware_map_loader/#directory-structure-of-these-files","title":"Directory structure of these files","text":"<p>If you only have one pointcloud map, Autoware will assume the following directory structure by default.</p> <pre><code>sample-map-rosbag\n\u251c\u2500\u2500 lanelet2_map.osm\n\u251c\u2500\u2500 pointcloud_map.pcd\n</code></pre> <p>If you have multiple rosbags, an example directory structure would be as follows. Note that you need to have a metadata when you have multiple pointcloud map files.</p> <pre><code>sample-map-rosbag\n\u251c\u2500\u2500 lanelet2_map.osm\n\u251c\u2500\u2500 pointcloud_map.pcd\n\u2502 \u251c\u2500\u2500 A.pcd\n\u2502 \u251c\u2500\u2500 B.pcd\n\u2502 \u251c\u2500\u2500 C.pcd\n\u2502 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 map_projector_info.yaml\n\u2514\u2500\u2500 pointcloud_map_metadata.yaml\n</code></pre>"},{"location":"map/autoware_map_loader/#specific-features","title":"Specific features","text":""},{"location":"map/autoware_map_loader/#publish-raw-pointcloud-map-ros-2-topic","title":"Publish raw pointcloud map (ROS 2 topic)","text":"<p>The node publishes the raw pointcloud map loaded from the <code>.pcd</code> file(s).</p>"},{"location":"map/autoware_map_loader/#publish-downsampled-pointcloud-map-ros-2-topic","title":"Publish downsampled pointcloud map (ROS 2 topic)","text":"<p>The node publishes the downsampled pointcloud map loaded from the <code>.pcd</code> file(s). You can specify the downsample resolution by changing the <code>leaf_size</code> parameter.</p>"},{"location":"map/autoware_map_loader/#publish-metadata-of-pointcloud-map-ros-2-topic","title":"Publish metadata of pointcloud map (ROS 2 topic)","text":"<p>The node publishes the pointcloud metadata attached with an ID. Metadata is loaded from the <code>.yaml</code> file. Please see the description of <code>PointCloudMapMetaData.msg</code> for details.</p>"},{"location":"map/autoware_map_loader/#send-partial-pointcloud-map-ros-2-service","title":"Send partial pointcloud map (ROS 2 service)","text":"<p>Here, we assume that the pointcloud maps are divided into grids.</p> <p>Given a query from a client node, the node sends a set of pointcloud maps that overlaps with the queried area. Please see the description of <code>GetPartialPointCloudMap.srv</code> for details.</p>"},{"location":"map/autoware_map_loader/#send-differential-pointcloud-map-ros-2-service","title":"Send differential pointcloud map (ROS 2 service)","text":"<p>Here, we assume that the pointcloud maps are divided into grids.</p> <p>Given a query and set of map IDs, the node sends a set of pointcloud maps that overlap with the queried area and are not included in the set of map IDs. Please see the description of <code>GetDifferentialPointCloudMap.srv</code> for details.</p>"},{"location":"map/autoware_map_loader/#send-selected-pointcloud-map-ros-2-service","title":"Send selected pointcloud map (ROS 2 service)","text":"<p>Here, we assume that the pointcloud maps are divided into grids.</p> <p>Given IDs query from a client node, the node sends a set of pointcloud maps (each of which attached with unique ID) specified by query. Please see the description of <code>GetSelectedPointCloudMap.srv</code> for details.</p>"},{"location":"map/autoware_map_loader/#parameters","title":"Parameters","text":"Name Type Description Default Range enable_whole_load boolean Enable raw pointcloud map publishing True N/A enable_downsampled_whole_load boolean Enable downsampled pointcloud map publishing False N/A enable_partial_load boolean Enable partial pointcloud map server True N/A enable_selected_load boolean Enable selected pointcloud map server False N/A leaf_size float Downsampling leaf size (only used when enable_downsampled_whole_load is set true) 3.0 N/A pcd_paths_or_directory array Path(s) to pointcloud map file or directory [] N/A pcd_metadata_path string Path to pointcloud metadata file N/A"},{"location":"map/autoware_map_loader/#interfaces","title":"Interfaces","text":"<ul> <li><code>output/pointcloud_map</code> (sensor_msgs/msg/PointCloud2) : Raw pointcloud map</li> <li><code>output/pointcloud_map_metadata</code> (autoware_map_msgs/msg/PointCloudMapMetaData) : Metadata of pointcloud map</li> <li><code>output/debug/downsampled_pointcloud_map</code> (sensor_msgs/msg/PointCloud2) : Downsampled pointcloud map</li> <li><code>service/get_partial_pcd_map</code> (autoware_map_msgs/srv/GetPartialPointCloudMap) : Partial pointcloud map</li> <li><code>service/get_differential_pcd_map</code> (autoware_map_msgs/srv/GetDifferentialPointCloudMap) : Differential pointcloud map</li> <li><code>service/get_selected_pcd_map</code> (autoware_map_msgs/srv/GetSelectedPointCloudMap) : Selected pointcloud map</li> <li>pointcloud map file(s) (.pcd)</li> <li>metadata of pointcloud map(s) (.yaml)</li> </ul>"},{"location":"map/autoware_map_loader/#lanelet2_map_loader","title":"lanelet2_map_loader","text":""},{"location":"map/autoware_map_loader/#feature_1","title":"Feature","text":"<p>lanelet2_map_loader loads Lanelet2 file and publishes the map data as autoware_map_msgs/LaneletMapBin message. The node projects lan/lon coordinates into arbitrary coordinates defined in <code>/map/map_projector_info</code> from <code>map_projection_loader</code>. Please see autoware_map_msgs/msg/MapProjectorInfo.msg for supported projector types.</p>"},{"location":"map/autoware_map_loader/#how-to-run","title":"How to run","text":"<p><code>ros2 run autoware_map_loader lanelet2_map_loader --ros-args -p lanelet2_map_path:=path/to/map.osm</code></p>"},{"location":"map/autoware_map_loader/#subscribed-topics","title":"Subscribed Topics","text":"<ul> <li>~input/map_projector_info (autoware_map_msgs/MapProjectorInfo) : Projection type for Autoware</li> </ul>"},{"location":"map/autoware_map_loader/#published-topics","title":"Published Topics","text":"<ul> <li>~output/lanelet2_map (autoware_map_msgs/LaneletMapBin) : Binary data of loaded Lanelet2 Map</li> </ul>"},{"location":"map/autoware_map_loader/#parameters_1","title":"Parameters","text":"Name Type Description Default Range allow_unsupported_version boolean Flag to load unsupported format_version anyway. If true, just prints warning. true N/A center_line_resolution float Resolution of the Lanelet center line [m] 5.0 N/A use_waypoints boolean If true, <code>centerline</code> in the Lanelet2 map will be used as a <code>waypoints</code> tag. True N/A lanelet2_map_path string The lanelet2 map path pointing to the .osm file N/A <p><code>use_waypoints</code> decides how to handle a centerline. This flag enables to use the <code>overwriteLaneletsCenterlineWithWaypoints</code> function instead of <code>overwriteLaneletsCenterline</code>. Please see the document of the autoware_lanelet2_extension package in detail.</p> <p></p>"},{"location":"map/autoware_map_projection_loader/","title":"autoware_map_projection_loader","text":""},{"location":"map/autoware_map_projection_loader/#autoware_map_projection_loader","title":"autoware_map_projection_loader","text":""},{"location":"map/autoware_map_projection_loader/#feature","title":"Feature","text":"<p><code>autoware_map_projection_loader</code> is responsible for publishing <code>map_projector_info</code> that defines in which kind of coordinate Autoware is operating. This is necessary information especially when you want to convert from global (geoid) to local coordinate or the other way around.</p> <ul> <li>If <code>map_projector_info_path</code> DOES exist, this node loads it and publishes the map projection information accordingly.</li> <li>If <code>map_projector_info_path</code> does NOT exist, the node assumes that you are using the <code>MGRS</code> projection type, and loads the lanelet2 map instead to extract the MGRS grid.<ul> <li>DEPRECATED WARNING: This interface that uses the lanelet2 map is not recommended. Please prepare the YAML file instead.</li> </ul> </li> </ul>"},{"location":"map/autoware_map_projection_loader/#map-projector-info-file-specification","title":"Map projector info file specification","text":"<p>You need to provide a YAML file, namely <code>map_projector_info.yaml</code> under the <code>map_path</code> directory. For <code>pointcloud_map_metadata.yaml</code>, please refer to the Readme of <code>autoware_map_loader</code>.</p> <pre><code>sample-map-rosbag\n\u251c\u2500\u2500 lanelet2_map.osm\n\u251c\u2500\u2500 pointcloud_map.pcd\n\u251c\u2500\u2500 map_projector_info.yaml\n\u2514\u2500\u2500 pointcloud_map_metadata.yaml\n</code></pre> <p>There are three types of transformations from latitude and longitude to XYZ coordinate system as shown in the figure below. Please refer to the following details for the necessary parameters for each projector type.</p> <p></p>"},{"location":"map/autoware_map_projection_loader/#using-local-coordinate","title":"Using local coordinate","text":"<pre><code># map_projector_info.yaml\nprojector_type: Local\n</code></pre> <p>Note that even if you input scale_factor, it will be overwritten to 1.0.</p>"},{"location":"map/autoware_map_projection_loader/#limitation","title":"Limitation","text":"<p>The functionality that requires latitude and longitude will become unavailable.</p> <p>The currently identified unavailable functionalities are:</p> <ul> <li>GNSS localization</li> <li>Sending the self-position in latitude and longitude using ADAPI</li> </ul>"},{"location":"map/autoware_map_projection_loader/#using-mgrs","title":"Using MGRS","text":"<p>If you want to use MGRS, please specify the MGRS grid as well.</p> <pre><code># map_projector_info.yaml\nprojector_type: MGRS\nvertical_datum: WGS84\nmgrs_grid: 54SUE\n</code></pre> <p>Note that even if you input scale_factor, it will be overwritten to 0.9996.</p>"},{"location":"map/autoware_map_projection_loader/#limitation_1","title":"Limitation","text":"<p>It cannot be used with maps that span across two or more MGRS grids. Please use it only when it falls within the scope of a single MGRS grid.</p>"},{"location":"map/autoware_map_projection_loader/#using-localcartesianutm","title":"Using LocalCartesianUTM","text":"<p>If you want to use local cartesian UTM, please specify the map origin as well.</p> <pre><code># map_projector_info.yaml\nprojector_type: LocalCartesianUTM\nvertical_datum: WGS84\nmap_origin:\nlatitude: 35.6762 # [deg]\nlongitude: 139.6503 # [deg]\n</code></pre> <p>Note that even if you input scale_factor, it will be overwritten to 0.9996.</p>"},{"location":"map/autoware_map_projection_loader/#using-localcartesian","title":"Using LocalCartesian","text":"<p>If you want to use local cartesian WGS84, please specify the map origin as well.</p> <p>Currently LocalCartesian can only be used in lanelet2_map_loader, packages like gnss_poser doesn't support it right now.</p> <pre><code># map_projector_info.yaml\nprojector_type: LocalCartesian\nvertical_datum: WGS84\nmap_origin:\nlatitude: 35.6762 # [deg]\nlongitude: 139.6503 # [deg]\n</code></pre> <p>Note that even if you input scale_factor, it will be overwritten to 1.0.</p>"},{"location":"map/autoware_map_projection_loader/#using-transversemercator","title":"Using TransverseMercator","text":"<p>If you want to use Transverse Mercator projection, please specify the map origin as well. And specify the scale_factor of the map. If you didn't specify the scale_factor, it will be set 0.9996 as default value.</p> <pre><code># map_projector_info.yaml\nprojector_type: TransverseMercator\nvertical_datum: WGS84\nmap_origin:\nlatitude: 35.6762 # [deg]\nlongitude: 139.6503 # [deg]\nscale_factor: 0.9996\n</code></pre>"},{"location":"map/autoware_map_projection_loader/#published-topics","title":"Published Topics","text":"<ul> <li><code>~/map_projector_info</code> (autoware_map_msgs/MapProjectorInfo) : This topic shows the definition of map projector information</li> </ul>"},{"location":"map/autoware_map_projection_loader/#parameters","title":"Parameters","text":"<p>Note that these parameters are assumed to be passed from launch arguments, and it is not recommended to directly write them in <code>map_projection_loader.param.yaml</code>.</p> Name Type Description Default Range map_projector_info_path string The path where map_projector_info.yaml is located $(var map_projector_info_path) N/A lanelet2_map_path string The path where the lanelet2 map file (.osm) is located $(var lanelet2_map_path) N/A"},{"location":"perception/autoware_core_perception/","title":"Autoware Core Perception","text":""},{"location":"perception/autoware_core_perception/#autoware-core-perception","title":"Autoware Core Perception","text":""},{"location":"perception/autoware_core_perception/#overview","title":"Overview","text":"<p>The <code>autoware_core_perception</code> is a meta-package within the Autoware project, designed to manage and organize various perception modules essential for autonomous vehicle operations. This package serves as a central point for integrating different perception capabilities, such as object detection, tracking, and sensor fusion.</p>"},{"location":"perception/autoware_core_perception/#usage","title":"Usage","text":"<p>The <code>autoware_core_perception</code> meta-package is used to launch and manage perception modules as part of the Autoware system. You can start the system using:</p> <pre><code>ros2 launch autoware_launch autoware.launch.xml\n</code></pre>"},{"location":"perception/autoware_ground_filter/","title":"autoware_ground_filter","text":""},{"location":"perception/autoware_ground_filter/#autoware_ground_filter","title":"autoware_ground_filter","text":""},{"location":"perception/autoware_ground_filter/#purpose","title":"Purpose","text":"<p>The <code>autoware_ground_filter</code> is a node that remove the ground points from the input pointcloud.</p>"},{"location":"perception/autoware_ground_filter/#inner-workings-algorithms","title":"Inner-workings / Algorithms","text":"<p>Detail description of each ground segmentation algorithm is in the following links.</p> Filter Name Description Detail ground_filter A method of removing the ground based on the geometrical relationship between points lined up on radiation link"},{"location":"perception/autoware_ground_filter/#inputs-outputs","title":"Inputs / Outputs","text":""},{"location":"perception/autoware_ground_filter/#input","title":"Input","text":"Name Type Description <code>~/input/points</code> <code>sensor_msgs::msg::PointCloud2</code> reference points <code>~/input/indices</code> <code>pcl_msgs::msg::Indices</code> reference indices"},{"location":"perception/autoware_ground_filter/#output","title":"Output","text":"Name Type Description <code>~/output/points</code> <code>sensor_msgs::msg::PointCloud2</code> filtered points"},{"location":"perception/autoware_ground_filter/#parameters","title":"Parameters","text":""},{"location":"perception/autoware_ground_filter/#node-parameters","title":"Node Parameters","text":"Name Type Default Value Description <code>input_frame</code> string \" \" input frame id <code>output_frame</code> string \" \" output frame id <code>max_queue_size</code> int 5 max queue size of input/output topics <code>use_indices</code> bool false flag to use pointcloud indices <code>latched_indices</code> bool false flag to latch pointcloud indices <code>approximate_sync</code> bool false flag to use approximate sync option"},{"location":"perception/autoware_ground_filter/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p>Implemented based on pcl_perception [1] because of this issue.</p>"},{"location":"perception/autoware_ground_filter/#referencesexternal-links","title":"References/External links","text":"<p>[1] https://github.com/ros-perception/perception_pcl/blob/ros2/pcl_ros/src/pcl_ros/filters/filter.cpp</p>"},{"location":"perception/autoware_ground_filter/docs/ground-filter/","title":"Autoware Ground Filter","text":""},{"location":"perception/autoware_ground_filter/docs/ground-filter/#autoware-ground-filter","title":"Autoware Ground Filter","text":"<p>This package is a alternative implementation of the following one</p> <ul> <li>autoware_ground_segmentation</li> <li>I also reused portions of the code from autoware_pointcloud_preprocessor as a reference.</li> </ul>"},{"location":"perception/autoware_ground_filter/docs/ground-filter/#purpose","title":"Purpose","text":"<p>The purpose of this node is that remove the ground points from the input pointcloud.</p>"},{"location":"perception/autoware_ground_filter/docs/ground-filter/#inner-workings-algorithms","title":"Inner-workings / Algorithms","text":"<p>This algorithm works by following steps,</p> <ol> <li>Divide whole pointclouds into groups by azimuth angle (so-called ray)</li> <li>Sort points by radial distance (xy-distance), on each ray.</li> <li>Divide pointcloud into grids, on each ray.</li> <li>Classify the point<ol> <li>Check radial distance to previous pointcloud, if the distance is large and previous pointcloud is \"no ground\" and the height level of current point greater than previous point, the current pointcloud is classified as no ground.</li> <li>Check vertical angle of the point compared with previous ground grid</li> <li>Check the height of the point compared with predicted ground level</li> <li>If vertical angle is greater than local_slope_max and related height to predicted ground level is greater than \"non ground height threshold\", the point is classified as \"non ground\"</li> <li>If the vertical angle is in range of [-local_slope_max, local_slope_max] or related height to predicted ground level is smaller than non_ground_height_threshold, the point is classified as \"ground\"</li> <li>If the vertical angle is lower than -local_slope_max or the related height to ground level is greater than detection_range_z_max, the point will be classified as out of range</li> </ol> </li> </ol>"},{"location":"perception/autoware_ground_filter/docs/ground-filter/#inputs-outputs","title":"Inputs / Outputs","text":"<p>This implementation inherits <code>rclcpp::Node</code> class, please refer README.</p>"},{"location":"perception/autoware_ground_filter/docs/ground-filter/#parameters","title":"Parameters","text":""},{"location":"perception/autoware_ground_filter/docs/ground-filter/#node-parameters","title":"Node Parameters","text":"<p>This implementation inherits <code>rclcpp::Node</code> class, please refer README.</p>"},{"location":"perception/autoware_ground_filter/docs/ground-filter/#core-parameters","title":"Core Parameters","text":"Name Type Default Value Description <code>input_frame</code> string \"base_link\" frame id of input pointcloud <code>output_frame</code> string \"base_link\" frame id of output pointcloud <code>global_slope_max_angle_deg</code> double 8.0 The global angle to classify as the ground or object [deg].A large threshold may reduce false positive of high slope road classification but it may lead to increase false negative of non-ground classification, particularly for small objects. <code>local_slope_max_angle_deg</code> double 10.0 The local angle to classify as the ground or object [deg] when comparing with adjacent point.A small value enhance accuracy classification of object with inclined surface. This should be considered together with <code>split_points_distance_tolerance</code> value. <code>radial_divider_angle_deg</code> double 1.0 The angle which divide the whole pointcloud to sliced group [deg] <code>split_points_distance_tolerance</code> double 0.2 The xy-distance threshold to distinguish far and near [m] <code>split_height_distance</code> double 0.2 The height threshold to distinguish ground and non-ground pointcloud when comparing with adjacent points [m]. A small threshold improves classification of non-ground point, especially for high elevation resolution pointcloud lidar. However, it might cause false positive for small step-like road surface or misaligned multiple lidar configuration. <code>use_virtual_ground_point</code> bool true whether to use the ground center of front wheels as the virtual ground point. <code>detection_range_z_max</code> float 2.5 Maximum height of detection range [m], applied only for elevation_grid_mode <code>center_pcl_shift</code> float 0.0 The x-axis offset of addition LiDARs from vehicle center of mass [m],  recommended to use only for additional LiDARs in elevation_grid_mode <code>non_ground_height_threshold</code> float 0.2 Height threshold of non ground objects [m] as <code>split_height_distance</code> and applied only for elevation_grid_mode <code>grid_mode_switch_radius</code> float 20.0 The distance where grid division mode change from by distance to by vertical angle [m], applied only for elevation_grid_mode <code>grid_size_m</code> float 0.5 The first grid size [m], applied only for elevation_grid_mode.A large value enhances the prediction stability for ground surface. suitable for rough surface or multiple lidar configuration. <code>ground_grid_buffer_size</code> uint16 4 Number of grids using to estimate local ground slope, applied only for elevation_grid_mode <code>low_priority_region_x</code> float -20.0 The non-zero x threshold in back side from which small objects detection is low priority [m] <code>elevation_grid_mode</code> bool true Elevation grid scan mode option <code>use_recheck_ground_cluster</code> bool true Enable recheck ground cluster <code>use_lowest_point</code> bool true to select lowest point for reference in recheck ground cluster, otherwise select middle point"},{"location":"perception/autoware_ground_filter/docs/ground-filter/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p>The input_frame is set as parameter but it must be fixed as base_link for the current algorithm.</p>"},{"location":"perception/autoware_ground_filter/docs/ground-filter/#optional-error-detection-and-handling","title":"(Optional) Error detection and handling","text":""},{"location":"perception/autoware_ground_filter/docs/ground-filter/#optional-performance-characterization","title":"(Optional) Performance characterization","text":""},{"location":"perception/autoware_ground_filter/docs/ground-filter/#optional-referencesexternal-links","title":"(Optional) References/External links","text":"<p>The elevation grid idea is referred from \"Shen Z, Liang H, Lin L, Wang Z, Huang W, Yu J. Fast Ground Segmentation for 3D LiDAR Point Cloud Based on Jump-Convolution-Process. Remote Sensing. 2021; 13(16):3239. https://doi.org/10.3390/rs13163239\"</p>"},{"location":"perception/autoware_ground_filter/docs/ground-filter/#optional-future-extensions-unimplemented-parts","title":"(Optional) Future extensions / Unimplemented parts","text":"<ul> <li>Horizontal check for classification is not implemented yet.</li> <li>Output ground visibility for diagnostic is not implemented yet.</li> </ul>"},{"location":"planning/autoware_core_planning/","title":"Autoware Core Planning","text":""},{"location":"planning/autoware_core_planning/#autoware-core-planning","title":"Autoware Core Planning","text":""},{"location":"planning/autoware_core_planning/#overview","title":"Overview","text":"<p>The <code>autoware_core_planning</code> is a meta-package within the Autoware project, designed to manage and organize various planning-related modules essential for autonomous vehicle operations. This package serves as a central point for integrating different planning functionalities, such as path planning, path optimization, and trajectory generation.</p>"},{"location":"planning/autoware_core_planning/#usage","title":"Usage","text":"<p>The <code>autoware_core_planning</code> meta-package is used to launch and manage planning modules as part of the Autoware system. You can start the system using:</p> <pre><code>ros2 launch autoware_launch planning_launch.xml\n</code></pre>"},{"location":"planning/autoware_mission_planner/","title":"Mission Planner","text":""},{"location":"planning/autoware_mission_planner/#mission-planner","title":"Mission Planner","text":""},{"location":"planning/autoware_mission_planner/#purpose","title":"Purpose","text":"<p><code>Mission Planner</code> calculates a route that navigates from the current ego pose to the goal pose following the given check points. The route is made of a sequence of lanes on a static map. Dynamic objects (e.g. pedestrians and other vehicles) and dynamic map information (e.g. road construction which blocks some lanes) are not considered during route planning. Therefore, the output topic is only published when the goal pose or check points are given and will be latched until the new goal pose or check points are given.</p> <p>The core implementation does not depend on a map format. Any planning algorithms can be added as plugin modules. In current Autoware Universe, only the plugin for Lanelet2 map format is supported.</p>"},{"location":"planning/autoware_mission_planner/#interfaces","title":"Interfaces","text":""},{"location":"planning/autoware_mission_planner/#parameters","title":"Parameters","text":"Name Type Description <code>map_frame</code> string The frame name for map <code>arrival_check_angle_deg</code> double Angle threshold for goal check <code>arrival_check_distance</code> double Distance threshold for goal check <code>arrival_check_duration</code> double Duration threshold for goal check <code>goal_angle_threshold</code> double Max goal pose angle for goal approve <code>enable_correct_goal_pose</code> bool Enabling correction of goal pose according to the closest lanelet orientation <code>reroute_time_threshold</code> double If the time to the rerouting point at the current velocity is greater than this threshold, rerouting is possible <code>minimum_reroute_length</code> double Minimum Length for publishing a new route <code>consider_no_drivable_lanes</code> bool This flag is for considering no_drivable_lanes in planning or not. <code>allow_reroute_in_autonomous_mode</code> bool This is a flag to allow reroute in autonomous driving mode. If false, reroute fails. If true, only safe reroute is allowed"},{"location":"planning/autoware_mission_planner/#services","title":"Services","text":"Name Type Description <code>/planning/mission_planning/mission_planner/clear_route</code> autoware_internal_planning_msgs/srv/ClearRoute route clear request <code>/planning/mission_planning/mission_planner/set_waypoint_route</code> autoware_internal_planning_msgs/srv/SetWaypointRoute route request with lanelet waypoints. <code>/planning/mission_planning/mission_planner/set_lanelet_route</code> autoware_internal_planning_msgs/srv/SetLaneletRoute route request with pose waypoints."},{"location":"planning/autoware_mission_planner/#subscriptions","title":"Subscriptions","text":"Name Type Description <code>input/vector_map</code> autoware_map_msgs/msg/LaneletMapBin vector map of Lanelet2 <code>input/operation_mode_state</code> autoware_adapi_v1_msgs/OperationModeState operation mode state <code>input/odometry</code> nav_msgs/msg/Odometry vehicle odometry"},{"location":"planning/autoware_mission_planner/#publications","title":"Publications","text":"Name Type Description <code>/planning/mission_planning/state</code> autoware_internal_planning_msgs/msg/RouteState route state <code>/planning/mission_planning/route</code> autoware_planning_msgs/LaneletRoute route <code>~/debug/route_marker</code> visualization_msgs/msg/MarkerArray route marker for debug <code>~/debug/goal_footprint</code> visualization_msgs/msg/MarkerArray goal footprint for debug"},{"location":"planning/autoware_mission_planner/#route-section","title":"Route section","text":"<p>Route section, whose type is <code>autoware_planning_msgs/LaneletSegment</code>, is a \"slice\" of a road that bundles lane changeable lanes. Note that the most atomic unit of route is <code>autoware_planning_msgs/LaneletPrimitive</code>, which has the unique id of a lane in a vector map and its type. Therefore, route message does not contain geometric information about the lane since we did not want to have planning module\u2019s message to have dependency on map data structure.</p> <p>The ROS message of route section contains following three elements for each route section.</p> <ul> <li><code>preferred_primitive</code>: Preferred lane to follow towards the goal.</li> <li><code>primitives</code>: All neighbor lanes in the same direction including the preferred lane.</li> </ul>"},{"location":"planning/autoware_mission_planner/#goal-validation","title":"Goal Validation","text":"<p>The mission planner has control mechanism to validate the given goal pose and create a route. If goal pose angle between goal pose lanelet and goal pose' yaw is greater than <code>goal_angle_threshold</code> parameter, the goal is rejected. Another control mechanism is the creation of a footprint of the goal pose according to the dimensions of the vehicle and checking whether this footprint is within the lanelets. If goal footprint exceeds lanelets, then the goal is rejected.</p> <p>At the image below, there are sample goal pose validation cases.</p> <p></p>"},{"location":"planning/autoware_mission_planner/#implementation","title":"Implementation","text":""},{"location":"planning/autoware_mission_planner/#mission-planner_1","title":"Mission Planner","text":"<p>Two callbacks (goal and check points) are a trigger for route planning. Routing graph, which plans route in Lanelet2, must be created before those callbacks, and this routing graph is created in vector map callback.</p> <p><code>plan route</code> is explained in detail in the following section.</p> <p></p>"},{"location":"planning/autoware_mission_planner/#route-planner","title":"Route Planner","text":"<p><code>plan route</code> is executed with check points including current ego pose and goal pose.</p> <p></p> <p><code>plan path between each check points</code> firstly calculates closest lanes to start and goal pose. Then routing graph of Lanelet2 plans the shortest path from start and goal pose.</p> <p><code>initialize route lanelets</code> initializes route handler, and calculates <code>route_lanelets</code>. <code>route_lanelets</code>, all of which will be registered in route sections, are lanelets next to the lanelets in the planned path, and used when planning lane change. To calculate <code>route_lanelets</code>,</p> <ol> <li>All the neighbor (right and left) lanes for the planned path which is lane-changeable is memorized as <code>route_lanelets</code>.</li> <li>All the neighbor (right and left) lanes for the planned path which is not lane-changeable is memorized as <code>candidate_lanelets</code>.</li> <li>If the following and previous lanelets of each <code>candidate_lanelets</code> are <code>route_lanelets</code>, the <code>candidate_lanelet</code> is registered as <code>route_lanelets</code><ul> <li>This is because even though <code>candidate_lanelet</code> (an adjacent lane) is not lane-changeable, we can pass the <code>candidate_lanelet</code> without lane change if the following and previous lanelets of the <code>candidate_lanelet</code> are <code>route_lanelets</code></li> </ul> </li> </ol> <p><code>get preferred lanelets</code> extracts <code>preferred_primitive</code> from <code>route_lanelets</code> with the route handler.</p> <p><code>create route sections</code> extracts <code>primitives</code> from <code>route_lanelets</code> for each route section with the route handler, and creates route sections.</p>"},{"location":"planning/autoware_mission_planner/#rerouting","title":"Rerouting","text":"<p>Reroute here means changing the route while driving. Unlike route setting, it is required to keep a certain distance from vehicle to the point where the route is changed. If the ego vehicle is not on autonomous driving state, the safety checking process will be skipped.</p> <p></p> <p>And there are three use cases that require reroute.</p> <ul> <li>Route change API</li> <li>Emergency route</li> <li>Goal modification</li> </ul>"},{"location":"planning/autoware_mission_planner/#route-change-api","title":"Route change API","text":"<p>It is used when changing the destination while driving or when driving a divided loop route. When the vehicle is driving on a MRM route, normal rerouting by this interface is not allowed.</p>"},{"location":"planning/autoware_mission_planner/#emergency-route","title":"Emergency route","text":"<p>The interface for the MRM that pulls over the road shoulder. It has to be stopped as soon as possible, so a reroute is required. The MRM route has priority over the normal route. And if MRM route is cleared, try to return to the normal route also with a rerouting safety check.</p>"},{"location":"planning/autoware_mission_planner/#goal-modification","title":"Goal modification","text":"<p>This is a goal change to pull over, avoid parked vehicles, and so on by a planning component. If the modified goal is outside the calculated route, a reroute is required. This goal modification is executed by checking the local environment and path safety as the vehicle actually approaches the destination. And this modification is allowed for both normal_route and mrm_route. The new route generated here is sent to the AD API so that it can also be referenced by the application. Note, however, that the specifications here are subject to change in the future.</p>"},{"location":"planning/autoware_mission_planner/#rerouting-limitations","title":"Rerouting Limitations","text":"<ul> <li>The safety judgment of rerouting is not guaranteed to the level of trajectory or control. Therefore, the distance to the reroute change must be large for the safety.</li> </ul>"},{"location":"planning/autoware_mission_planner/#limitations","title":"Limitations","text":"<ul> <li>Dynamic objects (e.g. pedestrians and other vehicles) and dynamic map information (e.g. road construction which blocks some lanes) are not considered during route planning.</li> <li>Looped route is not supported.</li> </ul>"},{"location":"planning/autoware_objects_of_interest_marker_interface/","title":"Objects Of Interest Marker Interface","text":""},{"location":"planning/autoware_objects_of_interest_marker_interface/#objects-of-interest-marker-interface","title":"Objects Of Interest Marker Interface","text":""},{"location":"planning/autoware_objects_of_interest_marker_interface/#overview","title":"Overview","text":"<p><code>autoware_objects_of_interest_marker_interface</code> is a collection of object visualization function packages.</p>"},{"location":"planning/autoware_objects_of_interest_marker_interface/#design","title":"Design","text":"<p>This package implement a library to manage and visualize the object information by construct and publish it as marker array to rviz.</p> <p>For a object to be visualized, it has three import characteristics.</p> <ul> <li>pose the position of the object</li> <li>shape the shape of the Bounding box of the object</li> <li>color the color of the Bounding box of the object</li> </ul>"},{"location":"planning/autoware_objects_of_interest_marker_interface/#usage","title":"Usage","text":""},{"location":"planning/autoware_objects_of_interest_marker_interface/#init","title":"init","text":"<p>include the header file to use then init the library</p> <pre><code>#include &lt;autoware/objects_of_interest_marker_interface/objects_of_interest_marker_interface.hpp&gt;\n\nautoware::objects_of_interest_marker_interface::ObjectsOfInterestMarkerInterface\nobjects_of_interest_marker_interface_{this, \"obstacle_cruise_planner\"};\n</code></pre>"},{"location":"planning/autoware_objects_of_interest_marker_interface/#insert","title":"insert","text":"<p>insert object information to the 'objects_of_interest_marker_interface' manager</p> <pre><code>using autoware::objects_of_interest_marker_interface::ColorName;\nobjects_of_interest_marker_interface_.insertObjectData(\nstopped_obstacle.pose, stopped_obstacle.shape, ColorName::RED);\n</code></pre>"},{"location":"planning/autoware_objects_of_interest_marker_interface/#publish","title":"publish","text":"<p>publish object information to the rviz to visualize</p> <pre><code>objects_of_interest_marker_interface_.publishMarkerArray();\n</code></pre>"},{"location":"planning/autoware_path_generator/","title":"Path Generator","text":""},{"location":"planning/autoware_path_generator/#path-generator","title":"Path Generator","text":"<p>The <code>path_generator</code> node receives a route from <code>mission_planner</code> and converts the center line into a path. If the route has waypoints set, it generates a path passing through them.</p> <p>This package is a simple alternative of <code>behavior_path_generator</code>.</p>"},{"location":"planning/autoware_path_generator/#path-generation","title":"Path generation","text":"<p>When input data is ready, it first searches for the lanelet closest to the vehicle. If found, it gets the lanelets within a distance of <code>path_length.backward</code> behind and <code>path_length.forward</code> in front. Their center lines are concatenated to generate a path.</p> <p>If waypoints exist in the route, it replaces the overlapped segment of the center line with them. The overlap interval is determined as shown in the following figure.</p> <p></p>"},{"location":"planning/autoware_path_generator/#path-cut","title":"Path cut","text":"<p>If there is a self-intersection on either of the path bounds, the path is cut off a specified distance before the first intersection, as shown in the following figure (path: green, bound: blue).</p> <p></p> <p>Depending on the crossing angle, the return path's bound may be closer to the centerline than the outward's one, depicted in the diagram below. To deal with this, intersections of the left and right bounds (mutual intersection) are taken into account as well, and the path is cut at the nearest intersecting point.</p> <p></p> <p>Furthermore, in the case of the following figure, the return path goes inside even if mutual intersection is considered. Therefore, path cut is also made when the start edge of the path and the path bounds intersect.</p> <p></p>"},{"location":"planning/autoware_path_generator/#turn-signal","title":"Turn signal","text":"<p>Turn signal is determined based on the rules defined for behavior_path_planner. (See here for details)</p> <p>As a general rule, the turn signal is turned on at a specified distance before the lanelet in which a turn is designated, and turned off when the driving direction has changed to the specified degree.</p> <p></p> <p>If consecutive turns are required, the turn signal corresponding to the required section or the last section takes precedence.</p> <p></p>"},{"location":"planning/autoware_path_generator/#hazard-signal","title":"Hazard signal","text":"<p>This node always publishes a hazard signal of <code>autoware_vehicle_msgs::msg::HazardLightsCommand::NO_COMMAND</code>.</p>"},{"location":"planning/autoware_path_generator/#flowchart","title":"Flowchart","text":""},{"location":"planning/autoware_path_generator/#input-topics","title":"Input topics","text":"Name Type Description <code>~/input/odometry</code> <code>nav_msgs::msg::Odometry</code> ego pose <code>~/input/vector_map</code> <code>autoware_map_msgs::msg::LaneletMapBin</code> vector map information <code>~/input/route</code> <code>autoware_planning_msgs::msg::LaneletRoute</code> current route from start to goal"},{"location":"planning/autoware_path_generator/#output-topics","title":"Output topics","text":"Name Type Description QoS Durability <code>~/output/path</code> <code>autoware_internal_planning_msgs::msg::PathWithLaneId</code> generated path <code>volatile</code> <code>~/output/turn_indicators_cmd</code> <code>autoware_vehicle_msgs::msg::TurnIndicatorsCommand</code> turn signal <code>volatile</code> <code>~/output/hazard_lights_cmd</code> <code>autoware_vehicle_msgs::msg::HazardLightsCommand</code> hazard signal <code>volatile</code>"},{"location":"planning/autoware_path_generator/#parameters","title":"Parameters","text":"Name Type Description Default Range planning_hz float Planning frequency [Hz] 10 \u22650.0 path_length.backward float Length of generated path behind vehicle [m] 5 \u22650.0 path_length.forward float Length of generated path in front of vehicle [m] 300 \u22650.0 waypoint_group.separation_threshold float Maximum distance at which consecutive waypoints are considered to belong to the same group [m] 1 \u22650.0 waypoint_group.interval_margin_ratio float Ratio for determining length of switching section from centerline to waypoints 10 \u22650.0 turn_signal.search_time float Time to search for start point of desired section [s] 3 \u22650.0 turn_signal.search_distance float Distance to search for start point of desired section [m] 30 \u22650.0 turn_signal.resampling_interval float Resampling interval for section start point interpolation [m] 1 \u22650.0 turn_signal.angle_threshold_deg float Threshold for determining end point of required section [deg] 15 \u22650.0 refine_goal_search_radius_range float Search radius for goal point refinement [m] 7.5 \u22650.0 search_radius_decrement float Decrement value for search radius [m] 1 \u22650.0 <p>In addition, the following parameters should be provided to the node:</p> <ul> <li>nearest search parameters</li> <li>vehicle info parameters</li> </ul>"},{"location":"planning/autoware_planning_factor_interface/","title":"autoware_planning_factor_interface","text":""},{"location":"planning/autoware_planning_factor_interface/#autoware_planning_factor_interface","title":"autoware_planning_factor_interface","text":""},{"location":"planning/autoware_planning_factor_interface/#overview","title":"Overview","text":"<p>The <code>PlanningFactorInterface</code> is a C++ class designed to facilitate the addition and publication of planning factors.</p>"},{"location":"planning/autoware_planning_factor_interface/#design","title":"Design","text":"<p>The <code>PlanningFactorInterface</code> class is designed to be lightweight and efficient, with the following key components:</p> <ul> <li>Add: Methods to add planning factors to the interface.</li> </ul> <ul> <li>Publisher: The class includes a publisher for <code>PlanningFactorArray</code> messages, which are used to distribute planning factors to other nodes in the system.</li> </ul> <p>The design emphasizes flexibility and ease of use, allowing developers to quickly integrate new planning factors into autoware.</p>"},{"location":"planning/autoware_planning_factor_interface/#usage","title":"Usage","text":""},{"location":"planning/autoware_planning_factor_interface/#including-the-header","title":"Including the Header","text":"<p>To use the <code>PlanningFactorInterface</code>, include the header file in your code:</p> <pre><code>#include &lt;autoware/planning_factor_interface/planning_factor_interface.hpp&gt;\n</code></pre>"},{"location":"planning/autoware_planning_factor_interface/#creating-an-instance","title":"Creating an Instance","text":"<p>Instantiate the <code>PlanningFactorInterface</code> by providing a node and a name for the factor module:</p> <pre><code>class PlannerInterface\n{\npublic:\nvirtual ~PlannerInterface() = default;\nPlannerInterface(\nrclcpp::Node &amp; node, const LongitudinalInfo &amp; longitudinal_info,\nconst autoware::vehicle_info_utils::VehicleInfo &amp; vehicle_info,\nconst EgoNearestParam &amp; ego_nearest_param, const std::shared_ptr&lt;DebugData&gt; debug_data_ptr)\n: planning_factor_interface_{std::make_unique&lt;\nautoware::planning_factor_interface::PlanningFactorInterface&gt;(\n&amp;node, \"obstacle_cruise_planner\")},\n</code></pre> <p>code example from src/universe/autoware_universe/planning/autoware_obstacle_cruise_planner/include/autoware/obstacle_cruise_planner/planner_interface.hpp</p>"},{"location":"planning/autoware_planning_factor_interface/#adding-planning-factors","title":"Adding Planning Factors","text":"<p>The <code>add</code> method can be used to add planning factors. Here's an example from src/universe/autoware_universe/planning/autoware_obstacle_cruise_planner/src/pid_based_planner/pid_based_planner.cpp.</p> <pre><code>planning_factor_interface_-&gt;add(\nstop_traj_points, planner_data.ego_pose, stop_traj_points.at(wall_idx).pose,\nautoware_internal_planning_msgs::msg::PlanningFactor::NONE,\nautoware_internal_planning_msgs::msg::SafetyFactorArray{});\n</code></pre>"},{"location":"planning/autoware_planning_factor_interface/#publishing-factors","title":"Publishing Factors","text":"<p>After adding planning factors, you can publish them by calling the <code>publish</code> method:</p> <pre><code>// Publish the added factors\nplanning_factor_interface_-&gt;publish();\n</code></pre>"},{"location":"planning/autoware_planning_topic_converter/","title":"Planning Topic Converter","text":""},{"location":"planning/autoware_planning_topic_converter/#planning-topic-converter","title":"Planning Topic Converter","text":""},{"location":"planning/autoware_planning_topic_converter/#purpose","title":"Purpose","text":"<p>This package provides tools that convert topic type among types are defined in https://github.com/autowarefoundation/autoware_msgs.</p>"},{"location":"planning/autoware_planning_topic_converter/#inner-workings-algorithms","title":"Inner-workings / Algorithms","text":""},{"location":"planning/autoware_planning_topic_converter/#usage-example","title":"Usage example","text":"<p>The tools in this package are provided as composable ROS 2 component nodes, so that they can be spawned into an existing process, launched from launch files, or invoked from the command line.</p> <pre><code>&lt;load_composable_node target=\"container_name\"&gt;\n&lt;composable_node pkg=\"planning_topic_converter\" plugin=\"autoware::planning_topic_converter::PathToTrajectory\" name=\"path_to_trajectory_converter\" namespace=\"\"&gt;\n&lt;!-- params --&gt;\n&lt;param name=\"input_topic\" value=\"foo\"/&gt;\n&lt;param name=\"output_topic\" value=\"bar\"/&gt;\n&lt;!-- composable node config --&gt;\n&lt;extra_arg name=\"use_intra_process_comms\" value=\"false\"/&gt;\n&lt;/composable_node&gt;\n&lt;/load_composable_node&gt;\n</code></pre>"},{"location":"planning/autoware_planning_topic_converter/#parameters","title":"Parameters","text":"Name Type Description <code>input_topic</code> string input topic name. <code>output_topic</code> string output topic name."},{"location":"planning/autoware_planning_topic_converter/#assumptions-known-limits","title":"Assumptions / Known limits","text":""},{"location":"planning/autoware_planning_topic_converter/#future-extensions-unimplemented-parts","title":"Future extensions / Unimplemented parts","text":""},{"location":"planning/autoware_route_handler/","title":"route handler","text":""},{"location":"planning/autoware_route_handler/#route-handler","title":"route handler","text":"<p><code>route_handler</code> is a library for calculating driving route on the lanelet map.</p>"},{"location":"planning/autoware_route_handler/#unit-testing","title":"Unit Testing","text":"<p>The unit testing depends on <code>autoware_test_utils</code> package. <code>autoware_test_utils</code> is a library that provides several common functions to simplify unit test creating.</p> <p></p> <p>By default, route file is necessary to create tests. The following illustrates the route that are used in the unit test</p>"},{"location":"planning/autoware_route_handler/#lane-change-test-route","title":"Lane change test route","text":"<ul> <li>The route is based on map that can be obtained from <code>autoware_test_utils\\test_map</code></li> </ul>"},{"location":"planning/autoware_velocity_smoother/","title":"Velocity Smoother","text":""},{"location":"planning/autoware_velocity_smoother/#velocity-smoother","title":"Velocity Smoother","text":""},{"location":"planning/autoware_velocity_smoother/#purpose","title":"Purpose","text":"<p><code>autoware_velocity_smoother</code> outputs a desired velocity profile on a reference trajectory. This module plans a velocity profile within the limitations of the velocity, the acceleration and the jerk to realize both the maximization of velocity and the ride quality. We call this module <code>autoware_velocity_smoother</code> because the limitations of the acceleration and the jerk means the smoothness of the velocity profile.</p>"},{"location":"planning/autoware_velocity_smoother/#inner-workings-algorithms","title":"Inner-workings / Algorithms","text":""},{"location":"planning/autoware_velocity_smoother/#flow-chart","title":"Flow chart","text":""},{"location":"planning/autoware_velocity_smoother/#extract-trajectory","title":"Extract trajectory","text":"<p>For the point on the reference trajectory closest to the center of the rear wheel axle of the vehicle, it extracts the reference path between <code>extract_behind_dist</code> behind and <code>extract_ahead_dist</code> ahead.</p>"},{"location":"planning/autoware_velocity_smoother/#apply-external-velocity-limit","title":"Apply external velocity limit","text":"<p>It applies the velocity limit input from the external of <code>autoware_velocity_smoother</code>. Remark that the external velocity limit is different from the velocity limit already set on the map and the reference trajectory. The external velocity is applied at the position that it is able to reach the velocity limit with the deceleration and the jerk constraints set as the parameter.</p>"},{"location":"planning/autoware_velocity_smoother/#apply-stop-approaching-velocity","title":"Apply stop approaching velocity","text":"<p>It applies the velocity limit near the stopping point. This function is used to approach near the obstacle or improve the accuracy of stopping.</p>"},{"location":"planning/autoware_velocity_smoother/#apply-lateral-acceleration-limit","title":"Apply lateral acceleration limit","text":"<p>It applies the velocity limit to decelerate at the curve. It calculates the velocity limit from the curvature of the reference trajectory and the maximum lateral acceleration <code>max_lateral_accel</code>. The velocity limit is set as not to fall under <code>min_curve_velocity</code>.</p> <p>Note: velocity limit that requests larger than <code>nominal.jerk</code> is not applied. In other words, even if a sharp curve is planned just in front of the ego, no deceleration is performed.</p>"},{"location":"planning/autoware_velocity_smoother/#apply-steering-rate-limit","title":"Apply steering rate limit","text":"<p>It calculates the desired steering angles of trajectory points. and it applies the steering rate limit. If the (<code>steering_angle_rate</code> &gt; <code>max_steering_angle_rate</code>), it decreases the velocity of the trajectory point to acceptable velocity.</p>"},{"location":"planning/autoware_velocity_smoother/#resample-trajectory","title":"Resample trajectory","text":"<p>It resamples the points on the reference trajectory with designated time interval. Note that the range of the length of the trajectory is set between <code>min_trajectory_length</code> and <code>max_trajectory_length</code>, and the distance between two points is longer than <code>min_trajectory_interval_distance</code>. It samples densely up to the distance traveled between <code>resample_time</code> with the current velocity, then samples sparsely after that. By sampling according to the velocity, both calculation load and accuracy are achieved since it samples finely at low velocity and coarsely at high velocity.</p>"},{"location":"planning/autoware_velocity_smoother/#calculate-initial-state","title":"Calculate initial state","text":"<p>Calculate initial values for velocity planning. The initial values are calculated according to the situation as shown in the following table.</p> Situation Initial velocity Initial acceleration First calculation Current velocity 0.0 Engaging <code>engage_velocity</code> <code>engage_acceleration</code> Deviate between the planned velocity and the current velocity Current velocity Previous planned value Normal Previous planned value Previous planned value"},{"location":"planning/autoware_velocity_smoother/#smooth-velocity","title":"Smooth velocity","text":"<p>It plans the velocity. The algorithm of velocity planning is chosen from <code>JerkFiltered</code>, <code>L2</code> and <code>Linf</code>, and it is set in the launch file. In these algorithms, they use OSQP[1] as the solver of the optimization.</p>"},{"location":"planning/autoware_velocity_smoother/#jerkfiltered","title":"JerkFiltered","text":"<p>It minimizes the sum of the minus of the square of the velocity and the square of the violation of the velocity limit, the acceleration limit and the jerk limit.</p>"},{"location":"planning/autoware_velocity_smoother/#l2","title":"L2","text":"<p>It minimizes the sum of the minus of the square of the velocity, the square of the the pseudo-jerk[2] and the square of the violation of the velocity limit and the acceleration limit.</p>"},{"location":"planning/autoware_velocity_smoother/#linf","title":"Linf","text":"<p>It minimizes the sum of the minus of the square of the velocity, the maximum absolute value of the the pseudo-jerk[2] and the square of the violation of the velocity limit and the acceleration limit.</p>"},{"location":"planning/autoware_velocity_smoother/#post-process","title":"Post process","text":"<p>It performs the post-process of the planned velocity.</p> <ul> <li>Set zero velocity ahead of the stopping point</li> <li>Set maximum velocity given in the config named <code>max_velocity</code></li> <li>Set velocity behind the current pose</li> <li>Resample trajectory (<code>post resampling</code>)</li> <li>Output debug data</li> </ul> <p>After the optimization, a resampling called <code>post resampling</code> is performed before passing the optimized trajectory to the next node. Since the required path interval from optimization may be different from the one for the next module, <code>post resampling</code> helps to fill this gap. Therefore, in <code>post resampling</code>, it is necessary to check the path specification of the following module to determine the parameters. Note that if the computational load of the optimization algorithm is high and the path interval is sparser than the path specification of the following module in the first resampling, <code>post resampling</code> would resample the trajectory densely. On the other hand, if the computational load of the optimization algorithm is small and the path interval is denser than the path specification of the following module in the first resampling, the path is sparsely resampled according to the specification of the following module.</p>"},{"location":"planning/autoware_velocity_smoother/#inputs-outputs","title":"Inputs / Outputs","text":""},{"location":"planning/autoware_velocity_smoother/#input","title":"Input","text":"Name Type Description <code>~/input/trajectory</code> <code>autoware_planning_msgs/Trajectory</code> Reference trajectory <code>/planning/scenario_planning/max_velocity</code> <code>std_msgs/Float32</code> External velocity limit [m/s] <code>/localization/kinematic_state</code> <code>nav_msgs/Odometry</code> Current odometry <code>/tf</code> <code>tf2_msgs/TFMessage</code> TF <code>/tf_static</code> <code>tf2_msgs/TFMessage</code> TF static"},{"location":"planning/autoware_velocity_smoother/#output","title":"Output","text":"Name Type Description <code>~/output/trajectory</code> <code>autoware_planning_msgs/Trajectory</code> Modified trajectory <code>/planning/scenario_planning/current_max_velocity</code> <code>std_msgs/Float32</code> Current external velocity limit [m/s] <code>~/closest_velocity</code> <code>std_msgs/Float32</code> Planned velocity closest to ego base_link (for debug) <code>~/closest_acceleration</code> <code>std_msgs/Float32</code> Planned acceleration closest to ego base_link (for debug) <code>~/closest_jerk</code> <code>std_msgs/Float32</code> Planned jerk closest to ego base_link (for debug) <code>~/debug/trajectory_raw</code> <code>autoware_planning_msgs/Trajectory</code> Extracted trajectory (for debug) <code>~/debug/trajectory_external_velocity_limited</code> <code>autoware_planning_msgs/Trajectory</code> External velocity limited trajectory (for debug) <code>~/debug/trajectory_lateral_acc_filtered</code> <code>autoware_planning_msgs/Trajectory</code> Lateral acceleration limit filtered trajectory (for debug) <code>~/debug/trajectory_steering_rate_limited</code> <code>autoware_planning_msgs/Trajectory</code> Steering angle rate limit filtered trajectory (for debug) <code>~/debug/trajectory_time_resampled</code> <code>autoware_planning_msgs/Trajectory</code> Time resampled trajectory (for debug) <code>~/distance_to_stopline</code> <code>std_msgs/Float32</code> Distance to stop line from current ego pose (max 50 m) (for debug) <code>~/stop_speed_exceeded</code> <code>std_msgs/Bool</code> It publishes <code>true</code> if planned velocity on the point which the maximum velocity is zero is over threshold"},{"location":"planning/autoware_velocity_smoother/#parameters","title":"Parameters","text":""},{"location":"planning/autoware_velocity_smoother/#constraint-parameters","title":"Constraint parameters","text":"Name Type Description Default value <code>max_velocity</code> <code>double</code> Max velocity limit [m/s] 20.0 <code>max_accel</code> <code>double</code> Max acceleration limit [m/ss] 1.0 <code>min_decel</code> <code>double</code> Min deceleration limit [m/ss] -0.5 <code>stop_decel</code> <code>double</code> Stop deceleration value at a stop point [m/ss] 0.0 <code>max_jerk</code> <code>double</code> Max jerk limit [m/sss] 1.0 <code>min_jerk</code> <code>double</code> Min jerk limit [m/sss] -0.5"},{"location":"planning/autoware_velocity_smoother/#external-velocity-limit-parameter","title":"External velocity limit parameter","text":"Name Type Description Default value <code>margin_to_insert_external_velocity_limit</code> <code>double</code> margin distance to insert external velocity limit [m] 0.3"},{"location":"planning/autoware_velocity_smoother/#curve-parameters","title":"Curve parameters","text":"Name Type Description Default value <code>enable_lateral_acc_limit</code> <code>bool</code> To toggle the lateral acceleration filter on and off. You can switch it dynamically at runtime. true <code>max_lateral_accel</code> <code>double</code> Max lateral acceleration limit [m/ss] 0.5 <code>min_curve_velocity</code> <code>double</code> Min velocity at lateral acceleration limit [m/ss] 2.74 <code>decel_distance_before_curve</code> <code>double</code> Distance to slowdown before a curve for lateral acceleration limit [m] 3.5 <code>decel_distance_after_curve</code> <code>double</code> Distance to slowdown after a curve for lateral acceleration limit [m] 2.0 <code>min_decel_for_lateral_acc_lim_filter</code> <code>double</code> Deceleration limit to avoid sudden braking by the lateral acceleration filter [m/ss]. Strong limitation degrades the deceleration response to the appearance of sharp curves due to obstacle avoidance, etc. -2.5"},{"location":"planning/autoware_velocity_smoother/#engage-replan-parameters","title":"Engage &amp; replan parameters","text":"Name Type Description Default value <code>replan_vel_deviation</code> <code>double</code> Velocity deviation to replan initial velocity [m/s] 5.53 <code>engage_velocity</code> <code>double</code> Engage velocity threshold [m/s] (if the trajectory velocity is higher than this value, use this velocity for engage vehicle speed) 0.25 <code>engage_acceleration</code> <code>double</code> Engage acceleration [m/ss] (use this acceleration when engagement) 0.1 <code>engage_exit_ratio</code> <code>double</code> Exit engage sequence to normal velocity planning when the velocity exceeds engage_exit_ratio x engage_velocity. 0.5 <code>stop_dist_to_prohibit_engage</code> <code>double</code> If the stop point is in this distance, the speed is set to 0 not to move the vehicle [m] 0.5"},{"location":"planning/autoware_velocity_smoother/#stopping-velocity-parameters","title":"Stopping velocity parameters","text":"Name Type Description Default value <code>stopping_velocity</code> <code>double</code> change target velocity to this value before v=0 point [m/s] 2.778 <code>stopping_distance</code> <code>double</code> distance for the stopping_velocity [m]. 0 means the stopping velocity is not applied. 0.0"},{"location":"planning/autoware_velocity_smoother/#extraction-parameters","title":"Extraction parameters","text":"Name Type Description Default value <code>extract_ahead_dist</code> <code>double</code> Forward trajectory distance used for planning [m] 200.0 <code>extract_behind_dist</code> <code>double</code> backward trajectory distance used for planning [m] 5.0 <code>delta_yaw_threshold</code> <code>double</code> Allowed delta yaw between ego pose and trajectory pose [radian] 1.0472"},{"location":"planning/autoware_velocity_smoother/#resampling-parameters","title":"Resampling parameters","text":"Name Type Description Default value <code>max_trajectory_length</code> <code>double</code> Max trajectory length for resampling [m] 200.0 <code>min_trajectory_length</code> <code>double</code> Min trajectory length for resampling [m] 30.0 <code>resample_time</code> <code>double</code> Resample total time [s] 10.0 <code>dense_dt</code> <code>double</code> resample time interval for dense sampling [s] 0.1 <code>dense_min_interval_distance</code> <code>double</code> minimum points-interval length for dense sampling [m] 0.1 <code>sparse_dt</code> <code>double</code> resample time interval for sparse sampling [s] 0.5 <code>sparse_min_interval_distance</code> <code>double</code> minimum points-interval length for sparse sampling [m] 4.0"},{"location":"planning/autoware_velocity_smoother/#resampling-parameters-for-post-process","title":"Resampling parameters for post process","text":"Name Type Description Default value <code>post_max_trajectory_length</code> <code>double</code> max trajectory length for resampling [m] 300.0 <code>post_min_trajectory_length</code> <code>double</code> min trajectory length for resampling [m] 30.0 <code>post_resample_time</code> <code>double</code> resample total time for dense sampling [s] 10.0 <code>post_dense_dt</code> <code>double</code> resample time interval for dense sampling [s] 0.1 <code>post_dense_min_interval_distance</code> <code>double</code> minimum points-interval length for dense sampling [m] 0.1 <code>post_sparse_dt</code> <code>double</code> resample time interval for sparse sampling [s] 0.1 <code>post_sparse_min_interval_distance</code> <code>double</code> minimum points-interval length for sparse sampling [m] 1.0"},{"location":"planning/autoware_velocity_smoother/#limit-steering-angle-rate-parameters","title":"Limit steering angle rate parameters","text":"Name Type Description Default value <code>enable_steering_rate_limit</code> <code>bool</code> To toggle the steer rate filter on and off. You can switch it dynamically at runtime. true <code>max_steering_angle_rate</code> <code>double</code> Maximum steering angle rate [degree/s] 40.0 <code>resample_ds</code> <code>double</code> Distance between trajectory points [m] 0.1 <code>curvature_threshold</code> <code>double</code> If curvature &gt; curvature_threshold, steeringRateLimit is triggered [1/m] 0.02 <code>curvature_calculation_distance</code> <code>double</code> Distance of points while curvature is calculating [m] 1.0"},{"location":"planning/autoware_velocity_smoother/#weights-for-optimization","title":"Weights for optimization","text":""},{"location":"planning/autoware_velocity_smoother/#jerkfiltered_1","title":"JerkFiltered","text":"Name Type Description Default value <code>jerk_weight</code> <code>double</code> Weight for \"smoothness\" cost for jerk 10.0 <code>over_v_weight</code> <code>double</code> Weight for \"over speed limit\" cost 100000.0 <code>over_a_weight</code> <code>double</code> Weight for \"over accel limit\" cost 5000.0 <code>over_j_weight</code> <code>double</code> Weight for \"over jerk limit\" cost 1000.0"},{"location":"planning/autoware_velocity_smoother/#l2_1","title":"L2","text":"Name Type Description Default value <code>pseudo_jerk_weight</code> <code>double</code> Weight for \"smoothness\" cost 100.0 <code>over_v_weight</code> <code>double</code> Weight for \"over speed limit\" cost 100000.0 <code>over_a_weight</code> <code>double</code> Weight for \"over accel limit\" cost 1000.0"},{"location":"planning/autoware_velocity_smoother/#linf_1","title":"Linf","text":"Name Type Description Default value <code>pseudo_jerk_weight</code> <code>double</code> Weight for \"smoothness\" cost 100.0 <code>over_v_weight</code> <code>double</code> Weight for \"over speed limit\" cost 100000.0 <code>over_a_weight</code> <code>double</code> Weight for \"over accel limit\" cost 1000.0"},{"location":"planning/autoware_velocity_smoother/#others","title":"Others","text":"Name Type Description Default value <code>over_stop_velocity_warn_thr</code> <code>double</code> Threshold to judge that the optimized velocity exceeds the input velocity on the stop point [m/s] 1.389"},{"location":"planning/autoware_velocity_smoother/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<ul> <li>Assume that the velocity limit or the stopping point is properly set at the point on the reference trajectory</li> <li>If the velocity limit set in the reference path cannot be achieved by the designated constraints of the deceleration and the jerk, decelerate while suppressing the velocity, the acceleration and the jerk deviation as much as possible</li> <li>The importance of the deviations is set in the config file</li> </ul>"},{"location":"planning/autoware_velocity_smoother/#optional-error-detection-and-handling","title":"(Optional) Error detection and handling","text":""},{"location":"planning/autoware_velocity_smoother/#optional-performance-characterization","title":"(Optional) Performance characterization","text":""},{"location":"planning/autoware_velocity_smoother/#optional-referencesexternal-links","title":"(Optional) References/External links","text":"<p>[1] B. Stellato, et al., \"OSQP: an operator splitting solver for quadratic programs\", Mathematical Programming Computation, 2020, 10.1007/s12532-020-00179-2.</p> <p>[2] Y. Zhang, et al., \"Toward a More Complete, Flexible, and Safer Speed Planning for Autonomous Driving via Convex Optimization\", Sensors, vol. 18, no. 7, p. 2185, 2018, 10.3390/s18072185</p>"},{"location":"planning/autoware_velocity_smoother/#optional-future-extensions-unimplemented-parts","title":"(Optional) Future extensions / Unimplemented parts","text":""},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_planner/","title":"Behavior Velocity Planner","text":""},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_planner/#behavior-velocity-planner","title":"Behavior Velocity Planner","text":""},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_planner/#overview","title":"Overview","text":"<p><code>behavior_velocity_planner</code> is a planner that adjust velocity based on the traffic rules. It loads modules as plugins. Please refer to the links listed below for detail on each module.</p> <p></p> <ul> <li>Blind Spot</li> <li>Crosswalk</li> <li>Walkway</li> <li>Detection Area</li> <li>Intersection</li> <li>MergeFromPrivate</li> <li>Stop Line</li> <li>Virtual Traffic Light</li> <li>Traffic Light</li> <li>Occlusion Spot</li> <li>No Stopping Area</li> <li>Run Out</li> <li>Speed Bump</li> </ul> <p>When each module plans velocity, it considers based on <code>base_link</code>(center of rear-wheel axis) pose. So for example, in order to stop at a stop line with the vehicles' front on the stop line, it calculates <code>base_link</code> position from the distance between <code>base_link</code> to front and modifies path velocity from the <code>base_link</code> position.</p> <p></p>"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_planner/#input-topics","title":"Input topics","text":"Name Type Description <code>~input/path_with_lane_id</code> autoware_internal_planning_msgs::msg::PathWithLaneId path with lane_id <code>~input/vector_map</code> autoware_map_msgs::msg::LaneletMapBin vector map <code>~input/vehicle_odometry</code> nav_msgs::msg::Odometry vehicle velocity <code>~input/dynamic_objects</code> autoware_perception_msgs::msg::PredictedObjects dynamic objects <code>~input/no_ground_pointcloud</code> sensor_msgs::msg::PointCloud2 obstacle pointcloud <code>~/input/compare_map_filtered_pointcloud</code> sensor_msgs::msg::PointCloud2 obstacle pointcloud filtered by compare map. Note that this is used only when the detection method of run out module is Points. <code>~input/traffic_signals</code> autoware_perception_msgs::msg::TrafficLightGroupArray traffic light states"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_planner/#output-topics","title":"Output topics","text":"Name Type Description <code>~output/path</code> autoware_planning_msgs::msg::Path path to be followed <code>~output/stop_reasons</code> tier4_planning_msgs::msg::StopReasonArray reasons that cause the vehicle to stop"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_planner/#node-parameters","title":"Node parameters","text":"Parameter Type Description <code>launch_modules</code> vector&lt;string&gt; module names to launch <code>forward_path_length</code> double forward path length <code>backward_path_length</code> double backward path length <code>max_accel</code> double (to be a global parameter) max acceleration of the vehicle <code>system_delay</code> double (to be a global parameter) delay time until output control command <code>delay_response_time</code> double (to be a global parameter) delay time of the vehicle's response to control commands"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_planner/#traffic-light-handling-in-simreal","title":"Traffic Light Handling in sim/real","text":"<p>The handling of traffic light information varies depending on the usage. In the below table, the traffic signal topic element for the corresponding lane is denoted as <code>info</code>, and if <code>info</code> is not available, it is denoted as <code>null</code>.</p> module \\ case <code>info</code> is <code>null</code> <code>info</code> is not <code>null</code> intersection_occlusion(<code>is_simulation = *</code>) <ul> <li><code>info</code> is the latest non-<code>null</code> information</li></ul> GO(occlusion is ignored) intersection_occlusion uses the latest non UNKNOWN observation in the queue up to present.<ul><li>If <code>info</code> is <code>GREEN or UNKNOWN</code>, occlusion is cared</li><li>If <code>info</code> is <code>RED or YELLOW</code>, occlusion is ignored(GO) </li> <li> NOTE: Currently timeout is not considered</li> </ul> traffic_light(sim, <code>is_simulation = true</code>) <ul> <li><code>info</code> is current information</li></ul> GO traffic_light uses the perceived traffic light information at present directly. <ul><li>If <code>info</code> is timeout, STOP whatever the color is</li> <li>If <code>info</code> is not timeout, then act according to the color. If <code>info</code> is <code>UNKNOWN</code>, STOP</li></ul> traffic_light(real, <code>is_simulation = false</code>) <ul> <li><code>info</code> is current information</li></ul> STOP \u2060 crosswalk with Traffic Light(<code>is_simulation = *</code>) <ul> <li><code>info</code> is current information</li></ul> default <ul> <li>If <code>disable_yield_for_new_stopped_object</code> is true, each sub scene_module ignore newly detected pedestrians after module instantiation.</li> <li>If <code>ignore_with_traffic_light</code> is true, occlusion detection is skipped.</li></ul> map_based_prediction(<code>is_simulation = *</code>) <ul> <li><code>info</code> is current information</li></ul> default If a pedestrian traffic light is<ul> <li>RED, surrounding pedestrians are not predicted.</li> <li>GREEN, stopped pedestrians are not predicted.</li></ul>"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_planner_common/","title":"Behavior Velocity Planner Common","text":""},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_planner_common/#behavior-velocity-planner-common","title":"Behavior Velocity Planner Common","text":"<p>This package provides a behavior velocity interface without RTC, and common functions as a library, which are used in the <code>behavior_velocity_planner</code> node and modules.</p>"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_stop_line_module/","title":"Stop Line","text":""},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_stop_line_module/#stop-line","title":"Stop Line","text":""},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_stop_line_module/#role","title":"Role","text":"<p>This module plans the vehicle's velocity to ensure it stops just before stop lines and can resume movement after stopping.</p> <p></p>"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_stop_line_module/#activation-timing","title":"Activation Timing","text":"<p>This module is activated when there is a stop line in a target lane.</p>"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_stop_line_module/#module-parameters","title":"Module Parameters","text":"Parameter Type Description <code>stop_margin</code> double Margin that the vehicle tries to stop in before stop_line <code>stop_duration_sec</code> double [s] Time parameter for the ego vehicle to stop before stop line <code>hold_stop_margin_distance</code> double [m] Parameter for restart prevention (See Algorithm section). Also, when the ego vehicle is within this distance from a stop line, the ego state becomes STOPPED from APPROACHING <code>use_initialization_stop_state</code> bool Flag to determine whether to return to the approaching state when the vehicle moves away from a stop line."},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_stop_line_module/#inner-workings-algorithms","title":"Inner-workings / Algorithms","text":"<ul> <li>Gets a stop line from map information.</li> <li>Inserts a stop point on the path from the stop line defined in the map and the ego vehicle length.</li> <li>Sets velocities of the path after the stop point to 0[m/s].</li> <li>Releases the inserted stop velocity when the vehicle halts at the stop point for <code>stop_duration_sec</code> seconds.</li> </ul>"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_stop_line_module/#flowchart","title":"Flowchart","text":"<p>This algorithm is based on <code>segment</code>. <code>segment</code> consists of two node points. It's useful for removing boundary conditions because if <code>segment(i)</code> exists we can assume <code>node(i)</code> and <code>node(i+1)</code> exist.</p> <p></p> <p>First, this algorithm finds a collision between reference path and stop line. Then, we can get <code>collision segment</code> and <code>collision point</code>.</p> <p></p> <p>Next, based on <code>collision point</code>, it finds <code>offset segment</code> by iterating backward points up to a specific offset length. The offset length is <code>stop_margin</code>(parameter) + <code>base_link to front</code>(to adjust head pose to stop line). Then, we can get <code>offset segment</code> and <code>offset from segment start</code>.</p> <p></p> <p>After that, we can calculate an offset point from <code>offset segment</code> and <code>offset</code>. This will be <code>stop_pose</code>.</p> <p></p>"},{"location":"planning/behavior_velocity_planner/autoware_behavior_velocity_stop_line_module/#restart-prevention","title":"Restart Prevention","text":"<p>If the vehicle requires X meters (e.g. 0.5 meters) to stop once it starts moving due to poor vehicle control performance, it may overshoot the stopping position, which must be strictly observed. This happens when the vehicle begins to move in order to approach a nearby stop point (e.g. 0.3 meters away).</p> <p>This module includes the parameter <code>hold_stop_margin_distance</code> to prevent redundant restarts in such a situation. If the vehicle is stopped within <code>hold_stop_margin_distance</code> meters of the stop point (_front_to_stop_line &lt; hold_stop_margin_distance), the module determines that the vehicle has already stopped at the stop point and will maintain the current stopping position, even if the vehicle has come to a stop due to other factors.</p> <p> </p> parameters <p> </p> outside the hold_stop_margin_distance <p> </p> inside the hold_stop_margin_distance"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/","title":"autoware_motion_velocity_obstacle_stop_module","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#autoware_motion_velocity_obstacle_stop_module","title":"autoware_motion_velocity_obstacle_stop_module","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#overview","title":"Overview","text":"<p>The <code>obstacle_stop</code> module does the stop planning when there is a static obstacle near the trajectory.</p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#design","title":"Design","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#obstacle-filtering","title":"Obstacle Filtering","text":"<p>The obstacles meeting the following condition are determined as obstacles for stopping.</p> <ul> <li>The object type is for stopping according to <code>obstacle_filtering.object_type.*</code>.</li> <li>The lateral distance from the object to the ego's trajectory is smaller than <code>obstacle_filtering.max_lat_margin</code>.</li> <li>The object velocity along the ego's trajectory is smaller than <code>obstacle_filtering.obstacle_velocity_threshold_from_stop</code>.</li> <li>The object<ul> <li>does not cross the ego's trajectory (*1)</li> <li>and its collision time margin is large enough (*2).</li> </ul> </li> </ul>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#note","title":"NOTE","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#1-crossing-obstacles","title":"*1: Crossing obstacles","text":"<p>Crossing obstacle is the object whose orientation's yaw angle against the ego's trajectory is smaller than <code>obstacle_filtering.crossing_obstacle.obstacle_traj_angle_threshold</code>.</p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#2-enough-collision-time-margin","title":"*2: Enough collision time margin","text":"<p>We predict the collision area and its time by the ego with a constant velocity motion and the obstacle with its predicted path. Then, we calculate a collision time margin which is the difference of the time when the ego will be inside the collision area and the obstacle will be inside the collision area. When this time margin is smaller than <code>obstacle_filtering.crossing_obstacle.collision_time_margin</code>, the margin is not enough.</p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#stop-planning","title":"Stop Planning","text":"<p>The role of the stop planning is keeping a safe distance with static vehicle objects or dynamic/static non vehicle objects.</p> <p>The stop planning just inserts the stop point in the trajectory to keep a distance with obstacles. The safe distance is parameterized as <code>stop_planning.stop_margin</code>. When it stops at the end of the trajectory, and obstacle is on the same point, the safe distance becomes <code>stop_planning.terminal_stop_margin</code>.</p> <p>When inserting the stop point, the required acceleration for the ego to stop in front of the stop point is calculated. If the acceleration is less than <code>common.min_strong_accel</code>, the stop planning will be cancelled since this package does not assume a strong sudden brake for emergency.</p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#minor-functions","title":"Minor functions","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#prioritization-of-behavior-modules-stop-point","title":"Prioritization of behavior module's stop point","text":"<p>When stopping for a pedestrian walking on the crosswalk, the behavior module inserts the zero velocity in the trajectory in front of the crosswalk. Also <code>autoware_obstacle_cruise_planner</code>'s stop planning also works, and the ego may not reach the behavior module's stop point since the safe distance defined in <code>autoware_obstacle_cruise_planner</code> may be longer than the behavior module's safe distance. To resolve this non-alignment of the stop point between the behavior module and this module, <code>stop_planning.min_behavior_stop_margin</code> is defined. In the case of the crosswalk described above, this module inserts the stop point with a distance <code>stop_planning.min_behavior_stop_margin</code> at minimum between the ego and obstacle.</p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#a-function-to-keep-the-closest-stop-obstacle-in-target-obstacles","title":"A function to keep the closest stop obstacle in target obstacles","text":"<p>In order to keep the closest stop obstacle in the target obstacles, we check whether it is disappeared or not from the target obstacles in the <code>check_consistency</code> function. If the previous closest stop obstacle is remove from the lists, we keep it in the lists for <code>obstacle_filtering.stop_obstacle_hold_time_threshold</code> seconds. Note that if a new stop obstacle appears and the previous closest obstacle removes from the lists, we do not add it to the target obstacles again.</p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#visualization","title":"Visualization","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#detection-area","title":"Detection area","text":"<p>Green polygons which is a detection area is visualized by <code>detection_polygons</code> in the <code>~/debug/marker</code> topic.</p> <p></p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#collision-points","title":"Collision points","text":"<p>Red points which are collision points with obstacle are visualized by <code>*_collision_points</code> for each behavior in the <code>~/debug/marker</code> topic.</p> <p></p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#obstacle-for-stop","title":"Obstacle for stop","text":"<p>Red sphere which is an obstacle for stop is visualized by <code>obstacles_to_stop</code> in the <code>~/debug/marker</code> topic.</p> <p>Red wall which means a safe distance to stop if the ego's front meets the wall is visualized in the <code>~/virtual_wall</code> topic.</p> <p></p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_obstacle_stop_module/#usage","title":"Usage","text":"<p>This module is activated if the launch parameter <code>launch_obstacle_stop_module</code> is set to true. e.g. launcher/autoware_launch/autoware_launch/config/planning/preset/default_preset.yaml</p> <pre><code># motion velocity planner modules\n- arg:\nname: launch_obstacle_stop_module\ndefault: \"true\"\n</code></pre> <p>That will trigger autoware_universe/launch/tier4_planning_launch/launch/scenario_planning/lane_driving/motion_planning/motion_planning.launch.xml to assemble launch config for motion_velocity_planner.</p> <p>Finally motion_velocity_planner will load <code>obstacle_stop_module</code> as plugin.</p> <pre><code>&lt;!-- assemble launch config for motion velocity planner --&gt;\n&lt;arg name=\"motion_velocity_planner_launch_modules\" default=\"[\"/&gt;\n&lt;let\nname=\"motion_velocity_planner_launch_modules\"\nvalue=\"$(eval &amp;quot;'$(var motion_velocity_planner_launch_modules)' + 'autoware::motion_velocity_planner::ObstacleStopModule, '&amp;quot;)\"\nif=\"$(var launch_obstacle_stop_module)\"\n/&gt;\n</code></pre>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner/","title":"Motion Velocity Planner","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner/#motion-velocity-planner","title":"Motion Velocity Planner","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner/#overview","title":"Overview","text":"<p><code>motion_velocity_planner</code> is a planner to adjust the trajectory velocity based on the obstacles around the vehicle. It loads modules as plugins. Please refer to the links listed below for detail on each module.</p> <p></p> <ul> <li>Out of Lane</li> </ul> <p>Each module calculates stop and slow down points to be inserted in the ego trajectory. These points are assumed to correspond to the <code>base_link</code> frame of the ego vehicle as it follows the trajectory. This means that to stop before a wall, a stop point is inserted in the trajectory at a distance ahead of the wall equal to the vehicle front offset (wheelbase + front overhang, see the vehicle dimensions.</p> <p></p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner/#input-topics","title":"Input topics","text":"Name Type Description <code>~/input/trajectory</code> autoware_planning_msgs::msg::Trajectory input trajectory <code>~/input/vector_map</code> autoware_map_msgs::msg::LaneletMapBin vector map <code>~/input/vehicle_odometry</code> nav_msgs::msg::Odometry vehicle position and velocity <code>~/input/accel</code> geometry_msgs::msg::AccelWithCovarianceStamped vehicle acceleration <code>~/input/dynamic_objects</code> autoware_perception_msgs::msg::PredictedObjects dynamic objects <code>~/input/no_ground_pointcloud</code> sensor_msgs::msg::PointCloud2 obstacle pointcloud <code>~/input/traffic_signals</code> autoware_perception_msgs::msg::TrafficLightGroupArray traffic light states <code>~/input/occupancy_grid</code> nav_msgs::msg::OccupancyGrid occupancy grid"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner/#output-topics","title":"Output topics","text":"Name Type Description <code>~/output/trajectory</code> autoware_planning_msgs::msg::Trajectory Ego trajectory with updated velocity profile <code>~/output/planning_factors/&lt;MODULE_NAME&gt;</code> autoware_internal_planning_msgs::msg::PlanningFactorsArray factors causing change in the ego velocity profile"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner/#services","title":"Services","text":"Name Type Description <code>~/service/load_plugin</code> autoware_motion_velocity_planner::srv::LoadPlugin To request loading a plugin <code>~/service/unload_plugin</code> autoware_motion_velocity_planner::srv::UnloadPlugin To request unloaded a plugin"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner/#node-parameters","title":"Node parameters","text":"Parameter Type Description <code>launch_modules</code> vector\\&lt;string&gt; module names to launch <p>In addition, the following parameters should be provided to the node:</p> <ul> <li>nearest search parameters;</li> <li>vehicle info parameters;</li> <li>common planning parameters;</li> <li>smoother parameters</li> <li>Parameters of each plugin that will be loaded.</li> </ul>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner_common/","title":"Motion Velocity Planner Common","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner_common/#motion-velocity-planner-common","title":"Motion Velocity Planner Common","text":"<p>This package provides common utilities and data structures for the motion velocity planner in the Autoware system. It contains tools for geometric calculations, trajectory processing, and velocity planning results.</p>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner_common/#overview","title":"Overview","text":"<p>Package motion velocity planner is responsible for generating velocity profiles for autonomous vehicles based on the current trajectory and environment. This package <code>autoware_motion_velocity_planner_common</code> contains essential utilities and structures that support the planning process, including:</p> <ul> <li>Geometric operations for polygons and trajectories.</li> <li>General utilities for trajectory processing and visualization.</li> <li>Data structures for storing velocity planning results.</li> </ul>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner_common/#design","title":"Design","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner_common/#key-components","title":"Key Components","text":"<ol> <li> <p>Polygon Utilities (<code>polygon_utils.hpp</code>)    This component provides functions for handling geometric polygons related to motion planning. It includes:</p> <ul> <li>Collision detection between trajectories and obstacles.</li> <li>Creation of polygons representing the vehicle's trajectory at different time steps.</li> <li>Geometric calculations using Boost Geometry.</li> </ul> </li> <li> <p>General Utilities (<code>utils.hpp</code>)    This component provides various utility functions, including:</p> <ul> <li>Conversion between point representations (e.g., <code>pcl::PointXYZ</code> to <code>geometry_msgs::msg::Point</code>).</li> <li>Distance calculations between trajectory points and obstacles.</li> <li>Functions for concatenating vectors and processing trajectories.</li> <li>Visualization tools for creating markers.</li> </ul> </li> <li> <p>Velocity Planning Results (<code>velocity_planning_result.hpp</code>)    This component defines data structures for storing the results of velocity planning, including:</p> <ul> <li><code>SlowdownInterval</code>: Represents a segment where the vehicle should slow down, with specified start and end points and velocity.</li> <li><code>VelocityPlanningResult</code>: Contains a collection of stop points, slowdown intervals, and optional velocity limits and clear commands.</li> </ul> </li> </ol>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner_common/#usage","title":"Usage","text":""},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner_common/#including-the-package","title":"Including the Package","text":"<p>To use this package in your project, you need to include it in your CMakeLists.txt:</p> <pre><code>find_package(autoware_motion_velocity_planner_common REQUIRED)\n</code></pre>"},{"location":"planning/motion_velocity_planner/autoware_motion_velocity_planner_common/#example-usage","title":"Example Usage","text":"<p>Here's a simple example demonstrating the use of the utility functions:</p> <pre><code>#include \"autoware/motion_velocity_planner_common/utils.hpp\"\n\nconst auto decimated_traj_points = autoware::motion_velocity_planner::utils::decimate_trajectory_points_from_ego(\ntraj_points, current_pose, ego_nearest_dist_threshold, ego_nearest_yaw_threshold,\np.decimate_trajectory_step_length, 0.0);\n</code></pre> <p>this example is from autoware_universe/planning/motion_velocity_planner/autoware_motion_velocity_obstacle_cruise_module/src/obstacle_cruise_module.cpp</p>"},{"location":"sensing/autoware_core_sensing/","title":"Autoware Core Sensing","text":""},{"location":"sensing/autoware_core_sensing/#autoware-core-sensing","title":"Autoware Core Sensing","text":""},{"location":"sensing/autoware_core_sensing/#overview","title":"Overview","text":"<p>The <code>autoware_core_sensing</code> is a meta-package within the Autoware project, designed to manage and organize various sensing-related modules essential for autonomous vehicle operations. This package serves as a central point for integrating different sensing functionalities, such as sensor data acquisition and preprocessing.</p>"},{"location":"sensing/autoware_core_sensing/#usage","title":"Usage","text":"<p>The <code>autoware_core_sensing</code> meta-package is used to launch and manage sensing modules as part of the Autoware system. You can start the system using:</p> <pre><code>ros2 launch autoware_launch sensing_launch.xml\n</code></pre>"},{"location":"sensing/autoware_crop_box_filter/","title":"autoware_crop_box_filter","text":""},{"location":"sensing/autoware_crop_box_filter/#autoware_crop_box_filter","title":"autoware_crop_box_filter","text":""},{"location":"sensing/autoware_crop_box_filter/#overview","title":"Overview","text":"<p>The <code>autoware_crop_box_filter</code> is a package that crops the input pointcloud to a specified bounding box. This is useful for reducing the computational load and improving the performance of the system.</p>"},{"location":"sensing/autoware_crop_box_filter/#design","title":"Design","text":"<p>The <code>autoware_crop_box_filter</code> is implemented as a autoware core node that subscribes to the input pointcloud, and publishes the filtered pointcloud. The bounding box is specified using the <code>min_point</code> and <code>max_point</code> parameters.</p>"},{"location":"sensing/autoware_crop_box_filter/#inputs-outputs","title":"Inputs / Outputs","text":""},{"location":"sensing/autoware_crop_box_filter/#input","title":"Input","text":"Name Type Description <code>~/input/points</code> <code>sensor_msgs::msg::PointCloud2</code> reference points"},{"location":"sensing/autoware_crop_box_filter/#output","title":"Output","text":"Name Type Description <code>~/output/points</code> <code>sensor_msgs::msg::PointCloud2</code> filtered points <code>~/crop_box_polygon</code> <code>geometry_msgs::msg::PolygonStamped</code> bounding box polygon"},{"location":"sensing/autoware_crop_box_filter/#parameters","title":"Parameters","text":""},{"location":"sensing/autoware_crop_box_filter/#launch-file-parameters","title":"Launch file Parameters","text":"Name Type Default Value Description <code>input_frame</code> string \" \" the frame id in which filtering is performed <code>output_frame</code> string \" \" output frame id of the filtered points <code>input_pointcloud_frame</code> string \" \" frame id of input pointcloud <code>max_queue_size</code> int 5 max buffer size of input/output topics <code>crop_box_filter_param_file</code> string \" \" path to the parameter file for the node"},{"location":"sensing/autoware_crop_box_filter/#node-parameters","title":"Node Parameters","text":"Name Type Default Value Description <code>min_x</code> double -5.0 minimum x value of the crop box <code>min_y</code> double -5.0 minimum y value of the crop box <code>min_z</code> double -5.0 minimum z value of the crop box <code>max_x</code> double 5.0 maximum x value of the crop box <code>max_y</code> double 5.0 maximum y value of the crop box <code>max_z</code> double 5.0 maximum z value of the crop box <code>negative</code> bool true if true, points inside the box are removed, otherwise points outside the box are removed"},{"location":"sensing/autoware_crop_box_filter/#usage","title":"Usage","text":""},{"location":"sensing/autoware_crop_box_filter/#1publish-static-tf-from-input-pointcloud-to-target-frame-that-is-used-for-filtering","title":"1.publish static tf from input pointcloud to target frame that is used for filtering","text":"<pre><code>ros2 run tf2_ros static_transform_publisher 2.0 3.2 1.3 0 0 0 1  velodyne_top_base_link  base_link\n</code></pre>"},{"location":"sensing/autoware_crop_box_filter/#2launch-node","title":"2.launch node","text":"<pre><code>ros2 launch autoware_crop_box_filter crop_box_filter_node.launch.xml\n</code></pre>"},{"location":"sensing/autoware_crop_box_filter/#3-launch-rviz2-and-awsim","title":"3. launch rviz2 and AWSIM","text":""},{"location":"sensing/autoware_gnss_poser/","title":"gnss_poser","text":""},{"location":"sensing/autoware_gnss_poser/#gnss_poser","title":"gnss_poser","text":""},{"location":"sensing/autoware_gnss_poser/#overview","title":"Overview","text":"<p>The <code>gnss_poser</code> is a node that subscribes gnss sensing messages and calculates vehicle pose with covariance.</p>"},{"location":"sensing/autoware_gnss_poser/#design","title":"Design","text":"<p>This node subscribes to NavSatFix to publish the pose of base_link. The data in NavSatFix represents the antenna's position. Therefore, it performs a coordinate transformation using the tf from <code>base_link</code> to the antenna's position. The frame_id of the antenna's position refers to NavSatFix's <code>header.frame_id</code>. (Note that <code>header.frame_id</code> in NavSatFix indicates the antenna's frame_id, not the Earth or reference ellipsoid. See also NavSatFix definition.)</p> <p>If the transformation from <code>base_link</code> to the antenna cannot be obtained, it outputs the pose of the antenna position without performing coordinate transformation.</p>"},{"location":"sensing/autoware_gnss_poser/#inputs-outputs","title":"Inputs / Outputs","text":""},{"location":"sensing/autoware_gnss_poser/#input","title":"Input","text":"Name Type Description <code>/map/map_projector_info</code> <code>autoware_map_msgs::msg::MapProjectorInfo</code> map projection info <code>~/input/fix</code> <code>sensor_msgs::msg::NavSatFix</code> gnss status message <code>~/input/autoware_orientation</code> <code>autoware_sensing_msgs::msg::GnssInsOrientationStamped</code> orientation click here for more details"},{"location":"sensing/autoware_gnss_poser/#output","title":"Output","text":"Name Type Description <code>~/output/pose</code> <code>geometry_msgs::msg::PoseStamped</code> vehicle pose calculated from gnss sensing data <code>~/output/gnss_pose_cov</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> vehicle pose with covariance calculated from gnss sensing data <code>~/output/gnss_fixed</code> <code>autoware_internal_debug_msgs::msg::BoolStamped</code> gnss fix status"},{"location":"sensing/autoware_gnss_poser/#parameters","title":"Parameters","text":"<p>Parameters in below table</p> Name Type Default Description <code>base_frame</code> <code>string</code> <code>base_link</code> frame id for base_frame <code>gnss_base_frame</code> <code>string</code> <code>gnss_base_link</code> frame id for gnss_base_frame <code>map_frame</code> <code>string</code> <code>map</code> frame id for map_frame <code>use_gnss_ins_orientation</code> <code>boolean</code> <code>true</code> use Gnss-Ins orientation <code>gnss_pose_pub_method</code> <code>integer</code> <code>0</code> 0: Instant Value 1: Average Value 2: Median Value. If <code>buffer_epoch</code> is set to 0, <code>gnss_pose_pub_method</code> loses affect. Range: 0~2. <code>buff_epoch</code> <code>integer</code> <code>1</code> Buffer epoch. Range: 0~inf. <p>All above parameters can be changed in config file gnss_poser.param.yaml .</p>"},{"location":"sensing/autoware_vehicle_velocity_converter/","title":"autoware_vehicle_velocity_converter","text":""},{"location":"sensing/autoware_vehicle_velocity_converter/#autoware_vehicle_velocity_converter","title":"autoware_vehicle_velocity_converter","text":""},{"location":"sensing/autoware_vehicle_velocity_converter/#purpose","title":"Purpose","text":"<p>This package converts autoware_vehicle_msgs::msg::VehicleReport message to geometry_msgs::msg::TwistWithCovarianceStamped for gyro odometer node.</p>"},{"location":"sensing/autoware_vehicle_velocity_converter/#inputs-outputs","title":"Inputs / Outputs","text":""},{"location":"sensing/autoware_vehicle_velocity_converter/#input","title":"Input","text":"Name Type Description <code>velocity_status</code> <code>autoware_vehicle_msgs::msg::VehicleReport</code> vehicle velocity"},{"location":"sensing/autoware_vehicle_velocity_converter/#output","title":"Output","text":"Name Type Description <code>twist_with_covariance</code> <code>geometry_msgs::msg::TwistWithCovarianceStamped</code> twist with covariance converted from VehicleReport"},{"location":"sensing/autoware_vehicle_velocity_converter/#parameters","title":"Parameters","text":"Name Type Description <code>speed_scale_factor</code> double speed scale factor (ideal value is 1.0) <code>frame_id</code> string frame id for output message <code>velocity_stddev_xx</code> double standard deviation for vx <code>angular_velocity_stddev_zz</code> double standard deviation for yaw rate"},{"location":"testing/autoware_planning_test_manager/","title":"Autoware Planning Test Manager","text":""},{"location":"testing/autoware_planning_test_manager/#autoware-planning-test-manager","title":"Autoware Planning Test Manager","text":""},{"location":"testing/autoware_planning_test_manager/#background","title":"Background","text":"<p>In each node of the planning module, when exceptional input, such as unusual routes or significantly deviated ego-position, is given, the node may not be prepared for such input and could crash. As a result, debugging node crashes can be time-consuming. For example, if an empty trajectory is given as input and it was not anticipated during implementation, the node might crash due to the unaddressed exceptional input when changes are merged, during scenario testing or while the system is running on an actual vehicle.</p>"},{"location":"testing/autoware_planning_test_manager/#purpose","title":"Purpose","text":"<p>The purpose is to provide a utility for implementing tests to ensure that node operates correctly when receiving exceptional input. By utilizing this utility and implementing tests for exceptional input, the purpose is to reduce bugs that are only discovered when actually running the system, by requiring measures for exceptional input before merging PRs.</p>"},{"location":"testing/autoware_planning_test_manager/#features","title":"Features","text":""},{"location":"testing/autoware_planning_test_manager/#confirmation-of-normal-operation","title":"Confirmation of normal operation","text":"<p>For the test target node, confirm that the node operates correctly and publishes the required messages for subsequent nodes. To do this, test_node publish the necessary messages and confirm that the node's output is being published.</p>"},{"location":"testing/autoware_planning_test_manager/#robustness-confirmation-for-special-inputs","title":"Robustness confirmation for special inputs","text":"<p>After confirming normal operation, ensure that the test target node does not crash when given exceptional input. To do this, provide exceptional input from the test_node and confirm that the node does not crash.</p> <p>(WIP)</p>"},{"location":"testing/autoware_planning_test_manager/#usage","title":"Usage","text":"<pre><code>TEST(PlanningModuleInterfaceTest, NodeTestWithExceptionTrajectory)\n{\nrclcpp::init(0, nullptr);\n\n// instantiate test_manager with PlanningInterfaceTestManager type\nauto test_manager = std::make_shared&lt;autoware::planning_test_manager::PlanningInterfaceTestManager&gt;();\n\n// get package directories for necessary configuration files\nconst auto autoware_test_utils_dir =\nament_index_cpp::get_package_share_directory(\"autoware_test_utils\");\nconst auto target_node_dir =\nament_index_cpp::get_package_share_directory(\"target_node\");\n\n// set arguments to get the config file\nnode_options.arguments(\n{\"--ros-args\", \"--params-file\",\nautoware_test_utils_dir + \"/config/test_vehicle_info.param.yaml\", \"--params-file\",\nautoware_planning_validator_dir + \"/config/planning_validator.param.yaml\"});\n\n// instantiate the TargetNode with node_options\nauto test_target_node = std::make_shared&lt;TargetNode&gt;(node_options);\n\n// publish the necessary topics from test_manager second argument is topic name\ntest_manager-&gt;publishOdometry(test_target_node, \"/localization/kinematic_state\");\ntest_manager-&gt;publishMaxVelocity(\ntest_target_node, \"velocity_smoother/input/external_velocity_limit_mps\");\n\n// set scenario_selector's input topic name(this topic is changed to test node)\ntest_manager-&gt;setTrajectoryInputTopicName(\"input/parking/trajectory\");\n\n// test with normal trajectory\nASSERT_NO_THROW(test_manager-&gt;testWithNominalTrajectory(test_target_node));\n\n// make sure target_node is running\nEXPECT_GE(test_manager-&gt;getReceivedTopicNum(), 1);\n\n// test with trajectory input with empty/one point/overlapping point\nASSERT_NO_THROW(test_manager-&gt;testWithAbnormalTrajectory(test_target_node));\n\n// shutdown ROS context\nrclcpp::shutdown();\n}\n</code></pre>"},{"location":"testing/autoware_planning_test_manager/#implemented-tests","title":"Implemented tests","text":"Node Test name exceptional input output Exceptional input pattern autoware_planning_validator NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points velocity_smoother NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points obstacle_cruise_planner NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points obstacle_stop_planner NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points obstacle_velocity_limiter NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points path_optimizer NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points scenario_selector NodeTestWithExceptionTrajectoryLaneDrivingMode NodeTestWithExceptionTrajectoryParkingMode trajectory scenario Empty, single point, path with duplicate points for scenarios:LANEDRIVING and PARKING freespace_planner NodeTestWithExceptionRoute route trajectory Empty route behavior_path_planner NodeTestWithExceptionRoute NodeTestWithOffTrackEgoPose route route odometry Empty route Off-lane ego-position behavior_velocity_planner NodeTestWithExceptionPathWithLaneID path_with_lane_id path Empty path"},{"location":"testing/autoware_planning_test_manager/#important-notes","title":"Important Notes","text":"<p>During test execution, when launching a node, parameters are loaded from the parameter file within each package. Therefore, when adding parameters, it is necessary to add the required parameters to the parameter file in the target node package. This is to prevent the node from being unable to launch if there are missing parameters when retrieving them from the parameter file during node launch.</p>"},{"location":"testing/autoware_planning_test_manager/#future-extensions-unimplemented-parts","title":"Future extensions / Unimplemented parts","text":"<p>(WIP)</p>"},{"location":"testing/autoware_pyplot/","title":"autoware_pyplot","text":""},{"location":"testing/autoware_pyplot/#autoware_pyplot","title":"autoware_pyplot","text":"<p>This package provides C++ interface for the notable <code>matplotlib</code> using <code>pybind11</code> backend for</p> <ul> <li>creating scientific plots and images illustrating the function inputs/outputs</li> <li>debugging the output and internal data of a function before unit testing in a more lightweight manner than planning_simulator</li> </ul>"},{"location":"testing/autoware_pyplot/#usage","title":"usage","text":"<p>In your main function, setup the python context and import <code>matplotlib</code></p> <pre><code>#include &lt;autoware/pyplot/pyplot.hpp&gt;\n#include &lt;pybind11/embed.h&gt;\n\n// in main...\npy::scoped_interpreter guard{};\nauto plt = autoware::pyplot::import();\n</code></pre> <p>Then you can use major functionalities of <code>matplotlib</code> almost in the same way as native python code.</p> <pre><code>{\nplt.plot(Args(std::vector&lt;int&gt;({1, 3, 2, 4})), Kwargs(\"color\"_a = \"blue\", \"linewidth\"_a = 1.0));\nplt.xlabel(Args(\"x-title\"));\nplt.ylabel(Args(\"y-title\"));\nplt.title(Args(\"title\"));\nplt.xlim(Args(0, 5));\nplt.ylim(Args(0, 5));\nplt.grid(Args(true));\nplt.savefig(Args(\"test_single_plot.png\"));\n}\n\n{\nauto [fig, axes] = plt.subplots(1, 2);\nauto &amp; ax1 = axes[0];\nauto &amp; ax2 = axes[1];\n\nax1.set_aspect(Args(\"equal\"));\nax2.set_aspect(Args(\"equal\"));\n}\n</code></pre>"},{"location":"testing/autoware_test_node/","title":"autoware_test_node","text":""},{"location":"testing/autoware_test_node/#autoware_test_node","title":"autoware_test_node","text":"<p>This package contains a simple example of how to use <code>autoware::Node</code>.</p>"},{"location":"testing/autoware_test_node/#usage","title":"Usage","text":"<pre><code>ros2 launch autoware_test_node autoware_test_node.launch.xml\n</code></pre>"},{"location":"testing/autoware_test_utils/","title":"Test Utils","text":""},{"location":"testing/autoware_test_utils/#test-utils","title":"Test Utils","text":""},{"location":"testing/autoware_test_utils/#background","title":"Background","text":"<p>Several Autoware's components and modules have already adopted unit testing, so a common library to ease the process of writing unit tests is necessary.</p>"},{"location":"testing/autoware_test_utils/#purpose","title":"Purpose","text":"<p>The objective of the <code>test_utils</code> is to develop a unit testing library for the Autoware components. This library will include</p> <ul> <li>commonly used functions</li> <li>input/mock data parser</li> <li>maps for testing</li> <li>common routes and mock data for testing.</li> </ul>"},{"location":"testing/autoware_test_utils/#available-maps","title":"Available Maps","text":"<p>The following maps are available here</p>"},{"location":"testing/autoware_test_utils/#common","title":"Common","text":"<p>The common map contains multiple types of usable inputs, including shoulder lanes, intersections, and some regulatory elements. The common map is named <code>lanelet2_map.osm</code> in the folder.</p> <p></p>"},{"location":"testing/autoware_test_utils/#2-km-straight","title":"2 km Straight","text":"<p>The 2 km straight lanelet map consists of two lanes that run in the same direction. The map is named <code>2km_test.osm</code>.</p> <p></p> <p>The following illustrates the design of the map.</p> <p></p>"},{"location":"testing/autoware_test_utils/#road_shoulders","title":"road_shoulders","text":"<p>The road_shoulders lanelet map consist of a variety of pick-up/drop-off site maps with road_shoulder tags including:</p> <ul> <li>pick-up/drop-off sites on the side of street lanes</li> <li>pick-up/drop-off sites on the side of curved lanes</li> <li>pick-up/drop-off sites inside a private area</li> </ul> <p></p> <p>You can easily launch planning_simulator by</p> <pre><code>ros2 launch autoware_test_utils psim_road_shoulder.launch.xml vehicle_model:=&lt;&gt; sensor_model:=&lt;&gt; use_sim_time:=true\n</code></pre>"},{"location":"testing/autoware_test_utils/#intersection","title":"intersection","text":"<p>The intersections lanelet map consist of a variety of intersections including:</p> <ul> <li>4-way crossing with traffic light</li> <li>4-way crossing without traffic light</li> <li>T-shape crossing without traffic light</li> <li>intersection with a loop</li> <li>complicated intersection</li> </ul> <p></p> <p>You can easily launch planning_simulator by</p> <pre><code>ros2 launch autoware_test_utils psim_intersection.launch.xml vehicle_model:=&lt;&gt; sensor_model:=&lt;&gt; use_sim_time:=true\n</code></pre>"},{"location":"testing/autoware_test_utils/#overlap","title":"overlap","text":"<p>The overlap lanelet map includes</p> <ul> <li>U-turn with a gap</li> <li>U-turn with full crossing</li> <li>U-turn with half crossing</li> <li>overpass</li> </ul> <p></p>"},{"location":"testing/autoware_test_utils/#example-use-cases","title":"Example use cases","text":""},{"location":"testing/autoware_test_utils/#autoware-planning-test-manager","title":"Autoware Planning Test Manager","text":"<p>The goal of the Autoware Planning Test Manager is to test planning module nodes. The <code>PlanningInterfaceTestManager</code> class (source code) creates wrapper functions based on the <code>test_utils</code> functions.</p>"},{"location":"testing/autoware_test_utils/#generate-test-data-for-unit-testing","title":"Generate test data for unit testing","text":"<p>As presented in this PR description, the user can save a snapshot of the scene to a yaml file while running Planning Simulation on the test map.</p> <pre><code>ros2 launch autoware_test_utils psim_road_shoulder.launch.xml\nros2 launch autoware_test_utils psim_intersection.launch.xml\n</code></pre> <p>It uses the autoware <code>sample_vehicle_description</code> and <code>sample_sensor_kit</code> by default, and <code>autoware_test_utils/config/test_vehicle_info.param.yaml</code> is exactly the same as that of <code>sample_vehicle_description</code>. If specified, <code>vehicle_model</code>/<code>sensor_model</code> argument is available.</p> <pre><code>ros2 service call /autoware_test_utils/topic_snapshot_saver std_srvs/srv/Empty \\{\\}\n</code></pre> <p>The list and field names of the topics to be saved are specified in <code>config/sample_topic_snapshot.yaml</code>.</p> <pre><code># setting\nfields:\n- name: self_odometry # this is the field name for this topic\ntype: Odometry # the abbreviated type name of this topic\ntopic: /localization/kinematic_state # the name of this topic\n\n# output\nself_odometry:\n- header: ...\n...\n</code></pre> <p>Each field can be parsed to ROS message type using the functions defined in <code>autoware_test_utils/mock_data_parser.hpp</code></p>"},{"location":"testing/autoware_testing/design/autoware_testing-design/","title":"autoware_testing","text":""},{"location":"testing/autoware_testing/design/autoware_testing-design/#autoware_testing","title":"autoware_testing","text":"<p>This is the design document for the <code>autoware_testing</code> package.</p>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#purpose-use-cases","title":"Purpose / Use cases","text":"<p>The package aims to provide a unified way to add standard testing functionality to the package, currently supporting:</p> <ul> <li>Smoke testing (<code>add_smoke_test</code>): launch a node with default configuration and ensure that it starts up and does not crash.</li> </ul>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#design","title":"Design","text":"<p>Uses <code>ros_testing</code> (which is an extension of <code>launch_testing</code>) and provides some parametrized, reusable standard tests to run.</p>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p>Parametrization is limited to package, executable names, parameters filename and executable arguments. Test namespace is set as 'test'. Parameters file for the package is expected to be in <code>param</code> directory inside package.</p>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#inputs-outputs-api","title":"Inputs / Outputs / API","text":"<p>To add a smoke test to your package tests, add test dependency on <code>autoware_testing</code> to <code>package.xml</code></p> <pre><code>&lt;test_depend&gt;autoware_testing&lt;/test_depend&gt;\n</code></pre> <p>and add the following two lines to <code>CMakeLists.txt</code> in the <code>IF (BUILD_TESTING)</code> section:</p> <pre><code>find_package(autoware_testing REQUIRED)\nadd_smoke_test(&lt;package_name&gt; &lt;executable_name&gt; [PARAM_FILENAME &lt;param_filename&gt;] [EXECUTABLE_ARGUMENTS &lt;arguments&gt;])\n</code></pre> <p>Where</p> <p><code>&lt;package_name&gt;</code> - [required] tested node package name.</p> <p><code>&lt;executable_name&gt;</code> - [required] tested node executable name.</p> <p><code>&lt;param_filename&gt;</code> - [optional] param filename. Default value is <code>test.param.yaml</code>. Required mostly in situation where there are multiple smoke tests in a package and each requires different parameters set</p> <p><code>&lt;arguments&gt;</code> - [optional] arguments passed to executable. By default no arguments are passed.</p> <p>which adds <code>&lt;executable_name&gt;_smoke_test</code> test to suite.</p> <p>Example test result:</p> <pre><code>build/&lt;package_name&gt;/test_results/&lt;package_name&gt;/&lt;executable_name&gt;_smoke_test.xunit.xml: 1 test, 0 errors, 0 failures, 0 skipped\n</code></pre>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#references-external-links","title":"References / External links","text":"<ul> <li>https://en.wikipedia.org/wiki/Smoke_testing_(software)</li> <li>https://github.com/ros2/ros_testing</li> <li>https://github.com/ros2/launch/blob/master/launch_testing</li> </ul>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#future-extensions-unimplemented-parts","title":"Future extensions / Unimplemented parts","text":"<ul> <li>Adding more types of standard tests.</li> </ul>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#related-issues","title":"Related issues","text":"<ul> <li>Issue #700: add smoke test</li> <li>Issue #1224: Port other packages with smoke tests to use <code>autoware_testing</code></li> </ul>"},{"location":"vehicle/autoware_core_vehicle/","title":"autoware_core_vehicle","text":""},{"location":"vehicle/autoware_core_vehicle/#autoware_core_vehicle","title":"autoware_core_vehicle","text":""},{"location":"vehicle/autoware_core_vehicle/#overview","title":"Overview","text":"<p>The <code>autoware_core_vehicle</code> package is a part of the Autoware Core system, responsible for interfacing with vehicle hardware and managing vehicle-specific operations. This package provides essential functionalities for vehicle control and communication within the Autoware ecosystem.</p>"},{"location":"vehicle/autoware_core_vehicle/#features","title":"Features","text":"<ul> <li>Vehicle driver interface</li> <li>Loading URDF model</li> </ul>"},{"location":"vehicle/autoware_core_vehicle/#configuration","title":"Configuration","text":"<p>The package can be configured using the following parameters:</p> <ul> <li><code>vehicle_model</code>: Specifies the package that contains urdf for vehicle model to be used.</li> <li><code>sensor_model</code>: Specifies the package that contains urdf for sensor models to be used.</li> </ul>"},{"location":"vehicle/autoware_core_vehicle/#launch-files","title":"Launch Files","text":"<ul> <li><code>vehicle.launch.xml</code>: Main launch file for vehicle operations.</li> </ul>"}]}